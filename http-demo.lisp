(defpackage :http-demo
  (:use :cl)
  (:export #:start-http-server))

(in-package :http-demo)

(defun send (stream control-string &rest arguments)
  "Buffered FORMAT."
  (declare (dynamic-extent argument))
  (write-sequence (apply 'format nil control-string arguments) stream))

(defun parse-http-request (line)
  (format t "Parsing request ~S.~%" line)
  (let ((request nil)
        (path '())
        (get-parameters nil)
        (extra nil)
        (offset 0))
    (dotimes (i (length line))
      (when (eql (char line i) #\Space)
        (return))
      (incf offset))
    (setf request (subseq line 0 offset))
    ;; Eat spaces.
    (do () ((or (>= offset (length line))
                (not (eql (char line offset) #\Space))))
      (incf offset))
    ;; Path must start with /
    (unless (eql (char line offset) #\/)
      (return-from parse-http-request (values nil nil nil nil)))
    (incf offset)
    ;; Break request apart with / as the seperator, stopping
    ;; at space, ? or eol.
    (do ((start offset))
        ((or (>= offset (length line))
             (member (char line offset) '(#\Space #\?)))
         (unless (eql start offset)
           (push (subseq line start offset) path)))
      (when (eql (char line offset) #\/)
        (push (subseq line start offset) path)
        (setf start (1+ offset)))
      (incf offset))
    (when (and (< offset (length line))
               (eql (char line offset) #\?))
      (let ((parameter-start (1+ offset)))
        (do () ((or (>= offset (length line))
                    (eql (char line offset) #\Space)))
          (incf offset))
        (setf get-parameters (subseq line parameter-start offset))))
    ;; Eat spaces.
    (do () ((or (>= offset (length line))
                (not (eql (char line offset) #\Space))))
      (incf offset))
    (values request (nreverse path) get-parameters (subseq line offset))))

(defun convert-newlines (string)
  (let ((doing-indentation t))
    (dotimes (i (length string))
      (case (char string i)
        (#\Newline
         (setf doing-indentation t)
         (write-string "<BR>")
         (terpri))
        (#\Space
         (if doing-indentation
             (write-string "&nbsp;")
             (write-char #\Space)))
        (t (setf doing-indentation nil)
           (write-char (char string i)))))))

(defun demo-file (stream)
  (let ((*standard-output* stream))
    (format t "HTTP/1.0 200 OK~%")
    (format t "Content-Type: text/html; charset=utf-8~%~%")
    (format t "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"~%")
    (format t "\"http://www.w3.org/TR/html4/loose.dtd\">~%")
    (format t "<HTML><HEAD><TITLE>(LISP OS)</TITLE></HEAD>~%")
    (format t "<BODY><H1>Hello, World!</H1><BR>~%")
    (convert-newlines
     (with-output-to-string (*standard-output*)
       (room)))
    (format t "<BR>~%")
    (format t "<BR>~%Running on ~A ~S<BR>~%"
            (lisp-implementation-type)
            (lisp-implementation-version))
    (format t "<IMG SRC=\"/logo300x100.jpg\" ALT=\"Made with Lisp.\">~%")
    (format t "</BODY></HTML>~%")))

(defun serve-request (stream)
  (with-simple-restart (abort "Give up")
    (with-open-stream (stream stream)
      (let ((line (read-line stream nil)))
        (when (null line)
          (return-from serve-request))
        (multiple-value-bind (request path get-parameters)
            (parse-http-request line)
          (format t "HTTP: ~S ~S ~S~%" request path get-parameters)
          (cond ((string-equal "GET" request)
                 (cond ((eql path '())
                        ;; Fully buffered output.
                        (with-output-to-string (s)
                          (demo-file s)
                          (write-sequence (get-output-stream-string s) stream)))
                       ((equal path '("char-by-char"))
                        ;; Character-by-character output.
                        (demo-file stream))
                       ((and (equalp path '("logo300x100.jpg"))
                             (boundp 'sys.int::*logo300x100.jpg*))
                        (send stream "HTTP/1.0 200 OK~%~%")
                        (write-sequence sys.int::*logo300x100.jpg* stream))
                       ((equalp path '("logo300x100.jpg"))
                        (with-open-file (s "logo300x100.jpg"
                                           :element-type '(unsigned-byte 8)
                                           :if-does-not-exist nil)
                          (cond (s (send stream "HTTP/1.0 200 OK~%~%")
                                   (let* ((file-size (file-length s))
                                          (buf (make-array file-size :element-type '(unsigned-byte 8))))
                                     (read-sequence buf s)
                                     (write-sequence buf stream)))
                                (t (send stream "HTTP/1.0 404 Not Found~%~%")))))
                       (t (send stream "HTTP/1.0 404 Not Found~%~%"))))
                (t (send stream "HTTP/1.0 400 Bad Request~%~%"))))))))

(defun http-server (connection-queue)
  (loop (sys.int::process-wait "Awaiting connection"
                               (lambda ()
                                 (symbol-value connection-queue)))
     (let ((connection (pop (symbol-value connection-queue))))
       (ignore-errors (serve-request connection)))))

(defun start-http-server-1 (&optional (connection-queue (gensym "HTTP-QUEUE")))
  (let ((process (sys.int::make-process "HTTP server")))
    (setf (symbol-value connection-queue) '())
    (sys.int::process-preset process #'http-server connection-queue)
    (sys.int::process-enable process)
    (values process
            (lambda (connection)
              (push (make-instance 'sys.net::tcp-stream :connection connection)
                    (symbol-value connection-queue)))
            connection-queue)))

(defun start-http-server (&optional (port 80))
  (multiple-value-bind (server-process listen-function)
      (start-http-server-1)
    (setf sys.net::*server-alist* (remove port sys.net::*server-alist*
                                          :key #'first))
    (push (list port listen-function) sys.net::*server-alist*)
    (values server-process listen-function)))
