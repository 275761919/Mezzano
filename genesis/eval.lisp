;;;; The genesis evaluator/translator.
;;;; This translates all forms into code that can be eval'd by the host.
;;;; There are two passes:
;;;; 1) Expand macros.
;;;;    Replace lexical variable and lambdas with objects.
;;;;    Trace where variables are accessed/escape.
;;;;    Replace Genesis symbols special forms with their host equivalent.
;;;;    Convert Genesis conses to host conses.
;;;;    ((lambda ...) ...) => (funcall #'(lambda ...) ...)
;;;; 2) Translate the modified form.

(in-package #:genesis)

(defvar *env* nil)

(defun parse-lambda (lambda)
  "Pull out the lambda list, a possible docstring, special declarations
and look for a LAMBDA-NAME declaration."
  (do ((lambda-list (second lambda))
       (body (cddr lambda) (cdr body))
       (name nil)
       (docstring nil)
       (specials '())
       (dec (genesis-intern "DECLARE"))
       (spec (genesis-intern "SPECIAL"))
       (lname (genesis-intern "LAMBDA-NAME")))
      ((or (not (consp body))
	   ;; A string at the end must always be treated as a
	   ;; body form, not a docstring.
	   (and (stringp (car body))
		(endp (cdr body)))
	   ;; Stop when (car body) is not a string and is not
	   ;; a declare form.
	   (not (or (stringp (car body))
		    (and (consp (car body))
			 (eql (car (car body)) dec)))))
       (values lambda-list body specials name docstring))
    (cond ((stringp (car body))
           (unless docstring
             (setf docstring (car body))))
          (t (dolist (dec (cdr (car body)))
               (cond
                 ;; (lambda-name NAME)
                 ((and (eql (car dec) lname)
                       (consp (cdr dec))
                       (endp (cdr (cdr dec)))
                       (null name))
                  (setf name (car (cdr dec))))
                 ;; (special ...)
                 ((eql (car dec) spec)
                  (dolist (var (cdr dec))
                    (pushnew var specials)))))))))

(defun parse-declares (forms)
  (do ((declare-sym (genesis-intern "DECLARE"))
       (decs '())
       (f forms (cdr f)))
      ((or (endp f)
	   (not (consp (car f)))
	   (not (eql (car (car f)) declare-sym)))
       (values f (nreverse decs)))
    (dolist (dec (cdr (car f)))
      (push dec decs))))

(defun get-special-declarations (declares)
  "Pull out a
 list of special variables from a list of declarations."
  (do* ((special-sym (genesis-intern "SPECIAL"))
	(vars '())
	(i declares (cdr i)))
       ((null i) vars)
    (when (eql (car (car i)) special-sym)
      (dolist (var (cdr (car i)))
	(pushnew var vars)))))

(defun parse-let-binding (binding)
  (cond ((consp binding)
         (values (car binding)
                 (if (consp (cdr binding))
                     (car (cdr binding))
                     'nil)))
        (t (values binding 'nil))))

(defun parse-lambda-list (ll)
  (let ((has-keys nil)
	(allow-other-keys nil)
	(required '())
	(optional '())
	(rest nil)
	(key '())
	(aux '())
	(opt-sym (genesis-intern "&OPTIONAL"))
	(rest-sym (genesis-intern "&REST"))
	(key-sym (genesis-intern "&KEY"))
	(aok-sym (genesis-intern "&ALLOW-OTHER-KEYS"))
	(aux-sym (genesis-intern "&AUX")))
    (labels ((parse-required (ll)
               (let ((current (first ll)))
                 (cond
                   ((endp ll))
                   ((eql current opt-sym)
                    (parse-optional (rest ll)))
                   ((eql current rest-sym)
                    (parse-rest (rest ll)))
                   ((eql current key-sym)
                    (parse-key (rest ll)))
                   ((eql current aok-sym)
                    (error "Unexpected &ALLOW-OTHER-KEYS in lambda-list."))
                   ((eql current aux-sym)
                    (parse-aux (rest ll)))
                   (t
                    (push current required)
                    (parse-required (rest ll))))))
	     (parse-optional (ll)
               (let ((current (first ll)))
                 (cond
                   ((endp ll))
                   ((eql current opt-sym)
                    (error "Unexpected &OPTIONAL in lambda-list."))
                   ((eql current rest-sym)
                    (parse-rest (rest ll)))
                   ((eql current key-sym)
                    (parse-key (rest ll)))
                   ((eql current aok-sym)
                    (error "Unexpected &ALLOW-OTHER-KEYS in lambda-list."))
                   ((eql current aux-sym)
                    (parse-aux (rest ll)))
                   (t
                    (cond
                      ((symbolp current)
                       (push (list current nil nil) optional))
                      ((= (length current) 3)
                       (push (list (first current)
                                   (second current)
                                   (third current))
                             optional))
                      ((= (length current) 2)
                       (push (list (first current)
                                   (second current)
                                   nil)
                             optional))
                      ((consp current)
                       (push (list (first current)
                                   nil
                                   nil)
                             optional))
                      (t (error "Invalid &OPTIONAL variable ~S." current)))
                    (parse-optional (rest ll))))))
	     (parse-rest (ll)
	       (when (endp ll)
		 (error "&REST without variable."))
               (let ((current (first ll))
                     (next (second ll)))
                 (when (or (eql current opt-sym)
                           (eql current rest-sym)
                           (eql current key-sym)
                           (eql current aok-sym)
                           (eql current aux-sym))
                   (error "Unexpected ~A in lambda-list." current))
                 (setf rest current)
                 (setf ll (rest ll))
                 (cond
                   ((endp ll))
                   ((eql next opt-sym)
                    (error "Unexpected &OPTIONAL in lambda-list."))
                   ((eql next rest-sym)
                    (error "Unexpected &REST in lambda-list."))
                   ((eql next key-sym)
                    (parse-key (rest ll)))
                   ((eql next aok-sym)
                    (error "Unexpected &ALLOW-OTHER-KEYS in lambda-list."))
                   ((eql next aux-sym)
                    (parse-aux (rest ll)))
                   (t (error "Malformed lambda-list (after &REST).")))))
	     (parse-key (ll)
               (let ((current (first ll)))
                 (setf has-keys t)
                 (cond
                   ((endp ll))
                   ((eql current opt-sym)
                    (error "Unexpected &OPTIONAL in lambda-list."))
                   ((eql current rest-sym)
                    (error "Unexpected &REST in lambda-list."))
                   ((eql current key-sym)
                    (error "Unexpected &KEY in lambda-list."))
                   ((eql current aok-sym)
                    (setf allow-other-keys t)
                    (cond
                      ((endp (rest ll)))
                      ((eql (second ll) aux-sym)
                       (parse-aux (cddr ll)))
                      (t (error "Malformed lambda-list (after &ALLOW-OTHER-KEYS)."))))
                   ((eql current aux-sym)
                    (parse-aux (rest ll)))
                   (t
                    (let ((keyword nil)
                          (name nil)
                          (init 'nil)
                          (suppliedp 'nil))
                      (etypecase current
                        (symbol
                         (setf name current
                               keyword (genesis-intern (symbol-name name) t)))
                        (cons
                         (let ((variable (first current)))
                           (when (> (length current) 3)
                             (error "Invalid key parameter ~S in lambda list. (List too long.)" current))
                           (cond
                             ((consp variable)
                              (when (or (not (= (length variable) 2))
                                        (not (symbolp (first variable)))
                                        (not (symbolp (second variable))))
                                (error "Invalid key parameter ~S in lambda list." current))
                              (setf name (second variable)
                                    keyword (first variable)))
                             (t (setf name variable
                                      keyword (genesis-intern (symbol-name name) "KEYWORD"))))
                           (setf init (second current)
                                 suppliedp (third current)))))
                      (push (list (list keyword name) init suppliedp) key))
                    (parse-key (rest ll))))))
	     (parse-aux (ll)
               (let ((current (first ll)))
                 (cond
                   ((endp ll))
                   ((eql current opt-sym)
                    (error "Unexpected &OPTIONAL in lambda-list."))
                   ((eql current rest-sym)
                    (error "Unexpected &REST in lambda-list."))
                   ((eql current key-sym)
                    (error "Unexpected &KEY in lambda-list."))
                   ((eql current aok-sym)
                    (error "Unexpected &ALLOW-OTHER-KEYS in lambda-list."))
                   ((eql current aux-sym)
                    (error "Unexpected &AUX in lambda-list."))
                   (t
                    (cond ((consp current)
                           (when (> (length current) 2)
                             (error "Invalid aux parameter ~S in lambda list." current))
                           (push (list (first current) (second current)) aux))
                          (t (push (list current nil) aux)))
                    (parse-aux (rest ll)))))))
      (parse-required ll)
      (values (nreverse required)
	      (nreverse optional)
	      rest
	      has-keys (nreverse key)
	      allow-other-keys
	      (nreverse aux)))))

(defun lambda-variables (lambda)
  (append (slot-value lambda 'required-args)
	  (mapcar #'car (slot-value lambda 'optional-args))
	  (delete 'nil (mapcar #'caddr (slot-value lambda 'optional-args)))
	  (when (slot-value lambda 'rest-arg)
	    (list (slot-value lambda 'rest-arg)))
	  (mapcar #'cadar (slot-value lambda 'key-args))
	  (delete 'nil (mapcar #'caddr (slot-value lambda 'key-args)))
	  (mapcar #'car (slot-value lambda 'aux-args))))

(defclass pass1-lambda ()
  ((source-form :initarg :source-form)
   (source-env :initarg :source-env)
   (name :initarg :name)
   (lambda-list :initarg :lambda-list)
   (specials :initarg :specials)
   (docstring :initarg :docstring)
   (required-args :initarg :required)
   (optional-args :initarg :optional)
   (rest-arg :initarg :rest)
   (has-keys :initarg :has-keys)
   (key-args :initarg :key)
   (allow-other-keys :initarg :allow-other-keys)
   (aux-args :initarg :aux)
   (body :initarg body)))

(defclass pass1-variable ()
  ((name :initarg :name)
   (symbol)
   (definition :initarg :definition)
   (used-in :initform '())
   (written :initform nil)))

(defmethod print-object ((object pass1-variable) stream)
  (print-unreadable-object (object stream :type t :identity t)
    (write (slot-value object 'name) :stream stream)))

(defun find-in-env (symbol env)
  "Scan ENV for SYMBOL, returning SYMBOL if no definition was found or if a special declaration was found,
otherwise the matching variable definition."
  (dolist (e env symbol)
    (when (eql (first e) :bindings)
      (when (find symbol (second e))
	(return symbol))
      (let ((foo (find symbol (third e) :key (lambda (x) (slot-value x 'name)))))
	(when foo (return foo))))))

(defun find-fn-in-env (name env)
  "Scan ENV for the function named NAME, return NIL if no definition was found."
  (dolist (e env)
    (when (eql (first e) :function-bindings)
      (let ((foo (assoc name (rest e) :test #'equal)))
	(when foo (return (cdr foo)))))))

(defvar *current-lambda* nil
  "The innermost lambda being translated by pass1.")

(defun pass1-lambda (lambda env)
  (multiple-value-bind (lambda-list body specials name docstring)
      (parse-lambda lambda)
    (multiple-value-bind (required optional rest has-keys key allow-other-keys aux)
	(parse-lambda-list lambda-list)
      (let ((*current-lambda* (make-instance 'pass1-lambda
					     :source-form lambda
					     :source-env env
					     :name name
					     :lambda-list lambda-list
					     :specials specials
					     :docstring docstring
					     :has-keys has-keys
					     :allow-other-keys allow-other-keys))
	    (env (cons (list :bindings specials '()) env)))
	(flet ((new-var (name)
		 (if (or (genesis-symbol-special-p name)
			 (member name specials))
		     name
		     (let ((foo (make-instance 'pass1-variable
					       :name name
					       :definition *current-lambda*)))
		       (push foo (third (car env)))
		       foo))))
	  (setf (slot-value *current-lambda* 'required-args) (mapcar #'new-var required)
		(slot-value *current-lambda* 'optional-args) (mapcar (lambda (x)
								       (list (new-var (first x))
									     (pass1-form (second x) env)
									     (if (eql (third x) nil)
										 nil
										 (new-var (third x)))))
								     optional)
		(slot-value *current-lambda* 'rest-arg) (when rest
							  (new-var rest))
		(slot-value *current-lambda* 'key-args) (mapcar (lambda (x)
								  (list (list (caar x)
									      (new-var (cadar x)))
									(pass1-form (second x) env)
									(if (eql (third x) nil)
									    nil
									    (new-var (third x)))))
								key)
		(slot-value *current-lambda* 'aux-args) (mapcar (lambda (x)
								  (list (new-var (first x))
									(pass1-form (second x) env)))
								aux))
	  (setf (slot-value *current-lambda* 'body) (pass1-implicit-progn body env))
	  *current-lambda*)))))

(defun pass1-implicit-progn (forms env)
  (do ((i forms (cdr i))
       (list '()))
      ((endp i)
       (nreverse list))
    (push (pass1-form (car i) env) list)))

(defun pass1-block (form env)
  (destructuring-bind (name &body body) (rest form)
    `(block ,name ,@(pass1-implicit-progn body env))))

(defun pass1-eval-when (form env)
  (destructuring-bind (situations &body body) (rest form)
    (dolist (situation situations)
      (when (or (eql situation (genesis-intern "EXECUTE" t))
                (eql situation (genesis-intern "EVAL" nil)))
        (return `(progn ,@(pass1-implicit-progn body env)))))))

(defun pass1-flet (form env)
  (destructuring-bind (functions &body forms) (rest form)
    (multiple-value-bind (body declares)
        (parse-declares forms)
      (let* ((specials (get-special-declarations declares))
             (new-env (cons (list :function-bindings) env)))
        ;; Accumulate bindings first.
        (dolist (fn functions)
          (let ((name (first fn)))
            (push (cons name (make-instance 'pass1-variable
                                            :name (if (consp name)
                                                      (car (cdr name))
                                                      name)
                                            :definition *current-lambda*))
                  (rest (car new-env)))))
        `(flet ,(do* ((result (cons nil nil))
                      (tail result (cdr tail))
                      (i functions (cdr i)))
                     ((endp i)
                      (cdr result))
                     (let* ((name (car (car i)))
                            (var (cdr (assoc name (rest (car new-env))))))
                       (setf (cdr tail) (cons (list var (pass1-lambda (fix-flet-function (car i)) env)) nil))))
           (progn ,@(pass1-implicit-progn body (cons (list :bindings specials '()) new-env))))))))

(defun pass1-function (form env)
  (destructuring-bind (name) (rest form)
    (if (and (consp name)
	     (eql (car name) (genesis-intern "LAMBDA")))
	`(function ,(pass1-lambda name env))
	(or (find-fn-in-env name env)
	    `(function ,name)))))

(defun pass1-go (form env)
  (declare (ignore env))
  (destructuring-bind (tag) (rest form)
    `(go ,tag)))

(defun pass1-if (form env)
  (destructuring-bind (test then &optional else) (rest form)
    `(if ,(pass1-form test env)
         ,(pass1-form then env)
         ,(pass1-form else env))))

(defun fix-flet-function (fn)
  "Convert an FLET function (name lambda-list . body) to (lambda lambda-list (declare (lambda-name name)) declares (block name . body)"
  (let* ((name (first fn))
	 (lambda-list (second fn)))
    ;; TODO: Preserve docstring.
    (multiple-value-bind (body declares)
        (parse-declares (cddr fn))
      (do* ((accu (cons nil nil))
            (tail accu (cdr tail))
            (i declares (cdr i)))
           ((endp i)
            (setf (cdr tail) (cons (list* (genesis-intern "BLOCK")
                                          (if (consp name)
                                              (second name)
                                              name)
                                          body)
                                   nil))
            (list* (genesis-intern "LAMBDA")
                   lambda-list
                   (list (genesis-intern "DECLARE") (list (genesis-intern "LAMBDA-NAME") name))
                   (cdr accu)))
        (setf (cdr tail) (cons (car i) nil))))))

(defun pass1-labels (form env)
  (destructuring-bind (functions &body forms) (rest form)
    (multiple-value-bind (body declares)
        (parse-declares forms)
      (let* ((specials (get-special-declarations declares))
             (env (cons (list :function-bindings) env)))
        ;; Accumulate bindings first.
        (dolist (fn functions)
          (let ((name (first fn)))
            (push (cons name (make-instance 'pass1-variable
                                            :name (if (consp name)
                                                      (second name)
                                                      name)
                                            :definition *current-lambda*))
                  (rest (car env)))))
        `(flet ,(do* ((result (cons nil nil))
                      (tail result (cdr tail))
                      (i functions (cdr i)))
                     ((endp i)
                      (cdr result))
                     (let* ((name (car (car i)))
                            (var (cdr (assoc name (rest (car env))))))
                       (setf (cdr tail) (cons (list var (pass1-lambda (fix-flet-function (car i)) env)) nil))))
           (progn ,@(pass1-implicit-progn body (cons (list :bindings specials '()) env))))))))

(defun pass1-let (form env)
  (destructuring-bind (bindings &body forms) (rest form)
    (multiple-value-bind (body declares)
        (parse-declares forms)
      (let* ((specials (get-special-declarations declares))
             (new-env (cons (list :bindings specials '()) env)))
        `(let ,(do* ((result (cons nil niL))
                     (tail result (cdr tail))
                     (i bindings (cdr i)))
                    ((endp i)
                     (cdr result))
                    (multiple-value-bind (name init-form)
                        (parse-let-binding (car i))
                      (setf (cdr tail) (cons (list (if (or (genesis-symbol-special-p name)
                                                           (member name specials))
                                                       name
                                                       (let ((x (make-instance 'pass1-variable
                                                                               :name name
                                                                               :definition *current-lambda*)))
                                                         (push x (third (car new-env)))
                                                         x))
                                                   (pass1-form init-form env))
                                             nil))))
           (progn ,@(pass1-implicit-progn body new-env)))))))

(defun pass1-let* (form env)
  (destructuring-bind (bindings &body forms) (rest form)
    (multiple-value-bind (body declares)
        (parse-declares forms)
      (let* ((specials (get-special-declarations declares))
             (env (cons (list :bindings specials '()) env)))
        `(let* ,(do* ((result (cons nil nil))
                      (tail result (cdr tail))
                      (i bindings (cdr i)))
                     ((endp i)
                      (cdr result))
                     (multiple-value-bind (name init-form)
                         (parse-let-binding (car i))
                       (let ((var (if (or (genesis-symbol-special-p name)
                                          (member name specials))
                                      name
                                      (make-instance 'pass1-variable
                                                     :name name
                                                     :definition *current-lambda*))))
                         (setf (cdr tail) (cons (list var (pass1-form init-form env)) nil))
                         (when (typep var 'pass1-variable)
                           (push var (third (car env)))))))
           (progn ,@(pass1-implicit-progn body env)))))))

(defun translate-macrolet-macro (name lambda-list forms)
  (multiple-value-bind (body declares)
      (parse-declares forms)
    ;; TODO: call into genesis & run the macroexpansion stuff.
    (unless (eql lambda-list '())
      (error "TODO: Macrolet with non-empty lambda-list."))
    (list (genesis-intern "FUNCTION")
          (list (genesis-intern "LAMBDA") (list (gensym "WHOLE") (gensym "ENV"))
                (list* (genesis-intern "DECLARE")
                       (list (genesis-intern "LAMBDA-NAME") name)
                       declares)
                (list* (genesis-intern "BLOCK") name
                       body)))))

(defun pass1-macrolet (form env)
  (destructuring-bind (macros &body forms) (rest form)
    (multiple-value-bind (body declares)
        (parse-declares forms)
      (let* ((specials (get-special-declarations declares))
             (env (list* (list :macros) (list :bindings specials '()) env)))
        (do ((i macros (cdr i)))
            ((endp i))
          (let* ((x (first i))
                 (name (first x))
                 (lambda-list (second x))
                 (body (cddr x)))
            (push (cons name (let ((*env* nil))
                               (genesis-eval (translate-macrolet-macro name lambda-list body))))
                  (cdar env))))
        `(progn ,@(pass1-implicit-progn body env))))))

(defun pass1-multiple-value-call (form env)
  (do* ((result (cons 'multiple-value-call nil))
	(tail result (cdr tail))
	(i (cdr form) (cdr i)))
       ((endp i) result)
    (setf (cdr tail) (cons (pass1-form (car i) env) nil))))

(defun pass1-multiple-value-prog1 (form env)
  (do* ((result (cons 'multiple-value-prog1 nil))
	(tail result (cdr tail))
	(i (cdr form) (cdr i)))
       ((endp i) result)
    (setf (cdr tail) (cons (pass1-form (car i) env) nil))))

(defun pass1-progn (form env)
  (do* ((result (cons 'progn nil))
	(tail result (cdr tail))
	(i (cdr form) (cdr i)))
       ((endp i)
	result)
    (setf (cdr tail) (cons (pass1-form (car i) env) nil))))

(defun pass1-quote (form env)
  (declare (ignore env))
  (destructuring-bind (object) (rest form)
    `(quote ,object)))

(defun pass1-return-from (form env)
  (destructuring-bind (name &optional value) (rest form)
    `(return-from ,name ,(pass1-form value env))))

;;; TODO: use setf with symbol macros.
(defun pass1-setq (form env)
  (do* ((result (cons 'progn nil))
	(tail result (cdr tail))
	(i (cdr form) (cddr i)))
       ((endp i)
	result)
    (when (null (cdr i))
      (error "Odd number of forms in SETQ."))
    (let* ((name (first i))
	   (value (second i))
	   (var (if (genesis-symbol-special-p name)
		    name
		    (find-in-env name env))))
      ;; TODO: symbol macros.
      (unless (symbolp var)
	(pushnew *current-lambda* (slot-value var 'used-in))
	(setf (slot-value var 'written) t))
      (setf (cdr tail) (cons `(setq ,var ,(pass1-form value env)) nil)))))

(defun pass1-tagbody (form env)
  `(tagbody ,@(mapcar (lambda (f)
                        (cond ((or (symbolp f)
                                   (integerp f))
                               f)
                              ((consp f)
                               (pass1-form f env))
                              (t (error "Not a valid go tag: ~S." f))))
                      (rest form))))

(defun pass1-the (form env)
  (destructuring-bind (value-type value) (rest form)
    `(the ,value-type ,(pass1-form value env))))

(defun pass1-unwind-protect (form env)
  (destructuring-bind (protected-form &body cleanup-forms) (rest form)
    `(unwind-protect ,(pass1-form protected-form env)
       ,@(mapcar (lambda (f) (pass1-form f env))
                 cleanup-forms))))

(defun pass1-form (form env)
  (cond
    ((symbolp form)
     (let ((var (if (genesis-symbol-special-p form)
		    form
		    (find-in-env form env))))
       (unless (symbolp var)
	 (pushnew *current-lambda* (slot-value var 'used-in)))
       var))
    ((not (consp form))
     `(quote ,form))
    ((and (consp (car form))
	  (eql (caar form) (genesis-intern "LAMBDA")))
     (list* (genesis-intern "FUNCALL")
	    (pass1-lambda (first form) env)
            (mapcar (lambda (f) (pass1-form f env))
                    (rest form))))
    ((not (symbolp (car form)))
     (error "Invalid function call ~S." form))
    ((eql (car form) (genesis-intern "BLOCK"))
     (pass1-block form env))
    ((eql (car form) (genesis-intern "CATCH"))
     (pass1-catch form env))
    ((eql (car form) (genesis-intern "EVAL-WHEN"))
     (pass1-eval-when form env))
    ((eql (car form) (genesis-intern "FLET"))
     (pass1-flet form env))
    ((eql (car form) (genesis-intern "FUNCTION"))
     (pass1-function form env))
    ((eql (car form) (genesis-intern "GO"))
     (pass1-go form env))
    ((eql (car form) (genesis-intern "IF"))
     (pass1-if form env))
    ((eql (car form) (genesis-intern "LABELS"))
     (pass1-labels form env))
    ((eql (car form) (genesis-intern "LET"))
     (pass1-let form env))
    ((eql (car form) (genesis-intern "LET*"))
     (pass1-let* form env))
    ((eql (car form) (genesis-intern "LOAD-TIME-VALUE"))
     (pass1-load-time-value form env))
    ((eql (car form) (genesis-intern "LOCALLY"))
     (pass1-locally form env))
    ((eql (car form) (genesis-intern "MACROLET"))
     (pass1-macrolet form env))
    ((eql (car form) (genesis-intern "MULTIPLE-VALUE-CALL"))
     (pass1-multiple-value-call form env))
    ((eql (car form) (genesis-intern "MULTIPLE-VALUE-PROG1"))
     (pass1-multiple-value-prog1 form env))
    ((eql (car form) (genesis-intern "PROGN"))
     (pass1-progn form env))
    ((eql (car form) (genesis-intern "PROGV"))
     (pass1-progv form env))
    ((eql (car form) (genesis-intern "QUOTE"))
     (pass1-quote form env))
    ((eql (car form) (genesis-intern "RETURN-FROM"))
     (pass1-return-from form env))
    ((eql (car form) (genesis-intern "SETQ"))
     (pass1-setq form env))
    ((eql (car form) (genesis-intern "SYMBOL-MACROLET"))
     (pass1-symbol-macrolet form env))
    ((eql (car form) (genesis-intern "TAGBODY"))
     (pass1-tagbody form env))
    ((eql (car form) (genesis-intern "THE"))
     (pass1-the form env))
    ((eql (car form) (genesis-intern "THROW"))
     (pass1-throw form env))
    ((eql (car form) (genesis-intern "UNWIND-PROTECT"))
     (pass1-unwind-protect form env))
    ((genesis-macro-function (car form) env)
     (pass1-form (funcall (genesis-macro-function (car form) env)
                          form env)
		 env))
    (t
     ;; Try transforming (funcall 'symbol ...) and (funcall #'name ...) into (name ...).
     ;; This also allows setf functions to go through compiler macros.
     (when (eql (first form) (genesis-intern "FUNCALL"))
       (cond ((and (consp (second form))
                   (or (eql (first (second form)) (genesis-intern "QUOTE"))
                       (eql (first (second form)) (genesis-intern "FUNCTION")))
                   (symbolp (second (second form))))
              (setf form (list* (second (second form)) (cddr form))))
             ((and (consp (second form))
                   (eql (first (second form)) (genesis-intern "FUNCTION"))
                   (consp (second (second form)))
                   (not (eql (first (second (second form))) (genesis-intern "LAMBDA"))))
              ;; (funcall #'(not-lambda ...) ...)
              (setf form (list* (resolve-function-name (second (second form)))
                                (cddr form))))))
     ;; Check for a compiler-macro.
     (let* ((compiler-macro-fn (getf (genesis-symbol-plist (first form)) (genesis-intern "COMPILER-MACRO-FUNCTION")))
            (new-form (if compiler-macro-fn
                          (funcall compiler-macro-fn form env)
                          form)))
       (cond ((eql new-form form)
              ;; No change, compile as-is
              (let* ((name (car form))
                     (lexical (find-fn-in-env name env))
                     (args (mapcar (lambda (f) (pass1-form f env))
                                   (rest form))))
                (if lexical
                    (list* (genesis-intern "FUNCALL")
                           lexical
                           args)
                    (list* name args))))
             (t ;; Changed, reparse.
              (pass1-form new-form env)))))))

(defun local-p (var)
  (or (null (slot-value var 'used-in))
      (and (null (cdr (slot-value var 'used-in)))
	   (eql (car (slot-value var 'used-in)) (slot-value var 'definition)))))

(defun translate-form (form env)
  (etypecase form
    (cons
     (case (car form)
       ((block)
	`(block ,(second form)
	   ,@(mapcar (lambda (f) (translate-form f env)) (cddr form))))
       ((catch) (error "TODO: ~S" (car form)))
       ((eval-when) (error "TODO: ~S" (car form)))
       ((flet)
	(let* ((lexicals (mapcar #'first (second form)))
	       (env-vars (remove-if #'local-p lexicals))
	       (local-vars (remove-if-not #'local-p lexicals))
	       (env (cons (cons local-vars env-vars) env)))
	  `(let (,@(when env-vars
			 (list `(*env* (vector *env* ,@(mapcar (constantly nil) env-vars)))))
		 ,@(mapcar (lambda (v)
			     (setf (slot-value v 'symbol) (gensym))
			     (list (slot-value v 'symbol) nil))
			   local-vars))
	     ,@(mapcar (lambda (x)
			 (let ((name (first x))
			       (lambda (second x)))
			   (if (member name local-vars)
			       `(setf ,(slot-value name 'symbol) (genesis-close-environment ,(translate-lambda lambda env) *env*
											    ',(slot-value lambda 'source-form)
											    ',(slot-value lambda 'source-env)))
			       `(setf (svref *env* ,(1+ (position name env-vars))) (genesis-close-environment ,(translate-lambda lambda env) *env*
                                                                                                              ',(slot-value lambda 'source-form)
													      ',(slot-value lambda 'source-env))))))
		       (second form))
	     ,(translate-implicit-progn (cddr form) env))))
       ((function)
	(if (typep (second form) 'pass1-lambda)
	    `(genesis-close-environment ,(translate-lambda (second form) env) *env*
					',(slot-value (second form) 'source-form)
					',(slot-value (second form) 'source-env))
	    `(genesis-fdefinition ',(second form))))
       ((go)
	form)
       ((if)
	`(if ,(translate-form (second form) env)
	     ,(translate-form (third form) env)
	     ,(translate-form (fourth form) env)))
       ((labels) (error "Should not see LABELS here."))
       ((let)
	(let* ((lexicals (remove-if #'symbolp (mapcar #'first (second form))))
	       (env-vars (remove-if #'local-p lexicals))
	       (local-vars (remove-if-not #'local-p lexicals))
	       (special-names '())
	       (special-values '())
	       (let-bindings '())
	       (env-values '())
	       (new-env (cons (cons local-vars env-vars) env)))
	  (dolist (x (second form))
	    (let ((name (first x))
		  (init-form (second x)))
	      (cond
		((symbolp name)
		 (let ((sym (gensym)))
		   (push name special-names)
		   (push sym special-values)
		   (push (list sym (translate-form init-form env)) let-bindings)))
		((member name local-vars)
		 (let ((sym (gensym (symbol-name (slot-value name 'name)))))
		   (setf (slot-value name 'symbol) sym)
		   (push (list sym (translate-form init-form env)) let-bindings)))
		(t
		 (let ((sym (gensym (symbol-name (slot-value name 'name)))))
		   (push sym env-values)
		   (push (list sym (translate-form init-form env)) let-bindings))))))
	  (let* ((body (translate-implicit-progn (cddr form) new-env))
		 (spec (if special-names
			   `(progv ',(nreverse special-names) (list ,@(nreverse special-values))
			      ,body)
			   body))
		 (env-binding (if env-values
				  `(let ((*env* (vector *env* ,@(nreverse env-values))))
				     ,spec)
				  spec)))
	    `(let ,(nreverse let-bindings)
	       ,env-binding))))
       ((let*)
	(let* ((lexicals (remove-if #'symbolp (mapcar #'first (second form))))
	       (env-vars (remove-if #'local-p lexicals))
	       (local-vars (remove-if-not #'local-p lexicals))
	       (let-body (cons 'progn nil))
	       (tail let-body)
	       (env (cons (cons local-vars env-vars) env)))
	  (dolist (x (second form))
	    (let ((name (first x))
		  (init-form (second x)))
	      (cond
		((symbolp name)
		 (setf (cdr tail) (cons `(progv ',(list name) (list ,(translate-form init-form env))) nil)
		       tail (last (cadr tail))))
		((member name local-vars)
		 (setf (slot-value name 'symbol) (gensym (symbol-name (slot-value name 'name)))
		       (cdr tail) (cons `(let ((,(slot-value name 'symbol) ,(translate-form init-form env)))) nil)
		       tail (last (cadr tail))))
		(t
		 (setf (cdr tail) (cons `(setf (svref *env* ,(1+ (position name env-vars))) ,(translate-form init-form env)) nil)
		       tail (cdr tail))))))
	  (setf (cdr tail) (cons (translate-implicit-progn (cddr form) env) nil))
	  (if env-vars
	      `(let ((old-env *env*)
		     (*env* (make-array ,(1+ (length env-vars)))))
		 (setf (svref *env* 0) old-env)
		 ,let-body)
	      let-body)))
       ((load-time-value) (error "TODO: ~S" (car form)))
       ((locally) (error "TODO: ~S" (car form)))
       ((macrolet) (error "Should not see MACROLET here."))
       ((multiple-value-call)
	`(multiple-value-call ,@(mapcar (lambda (f) (translate-form f env)) (cdr form))))
       ((multiple-value-prog1)
	`(multiple-value-prog1 ,@(mapcar (lambda (f) (translate-form f env)) (cdr form))))
       ((progn)
	(if (cdr form)
	    `(progn ,@(mapcar (lambda (f) (translate-form f env)) (cdr form)))
	    `(quote nil)))
       ((progv) (error "TODO: ~S" (car form)))
       ((quote)
	form)
       ((return-from)
	`(return-from ,(second form) ,(translate-form (third form) env)))
       ((setq)
	(let ((var (second form))
	      (val (third form)))
	  (cond ((symbolp var)
		 `(setf (symbol-value ',var) ,(translate-form val env)))
		((slot-boundp var 'symbol)
		 `(setf ,(slot-value var 'symbol) ,(translate-form val env)))
		(t (let ((ep '*env*))
		     (dolist (e env (error "~S not found in environment?!" var))
		       (let ((p (position var (rest e))))
			 (when p
			   (return `(setf (svref ,ep ,(1+ p)) ,(translate-form val env)))))
		       (when (rest e)
			 (setf ep `(svref ,ep 0)))))))))
       ((symbol-macrolet) (error "Should not see SYMBOL-MACROLET here."))
       ((tagbody)
	`(tagbody ,@(mapcar (lambda (f)
			      (if (or (integerp f) (symbolp f))
				  f
				  (translate-form f env)))
			    (cdr form))))
       ((the)
	;; TODO, actual type check here.
	(translate-form (caddr form) env))
       ((throw) (error "TODO: ~S" (car form)))
       ((unwind-protect)
	`(unwind-protect ,@(mapcar (lambda (x) (translate-form x env)) (cdr form))))
       (t (let ((replacement (get (car form) 'genesis-replace-with)))
            (append (cond ((consp replacement)
                           `(funcall #',replacement))
                          (replacement (list replacement))
                          (t (list (car form))))
                    (do* ((list (cons nil nil))
                          (rest list (cdr rest))
                          (i (cdr form) (cdr i)))
                         ((null i) (cdr list))
                      (setf (cdr rest) (cons (translate-form (car i) env) nil))))))))
    (pass1-variable
     (if (slot-boundp form 'symbol)
	 (slot-value form 'symbol)
	 (let ((ep '*env*))
	   (dolist (e env (error "~S not found in environment?!" form))
	     (let ((p (position form (rest e))))
	       (when p
		 (return `(svref ,ep ,(1+ p)))))
	     (when (rest e)
	       (setf ep `(svref ,ep 0)))))))
    (symbol
     (if (and (boundp form)
              (genesis-symbol-constant-p form))
         `(quote ,(symbol-value form))
         `(symbol-value ',form)))))

(defun translate-implicit-progn (forms env)
  `(progn ,@(mapcar (lambda (f) (translate-form f env)) forms)))

(defun translate-lambda (lambda env)
  "Convert a pass1-lambda to code."
  (let* ((name (if (slot-value lambda 'name)
                   (if (symbolp (slot-value lambda 'name))
                       (slot-value lambda 'name)
                       (make-symbol (format nil "~A" (slot-value lambda 'name))))
		   (gensym "LAMBDA")))
	 (new-ll '())
	 (lambda-body (cons nil nil))
	 (tail lambda-body)
	 (lexicals (remove-if #'symbolp (lambda-variables lambda)))
	 (env-vars (remove-if #'local-p lexicals))
	 (local-vars (remove-if-not #'local-p lexicals))
	 (env (if lexicals (cons (cons local-vars env-vars) env) env))
	 (rest-sym (when (or (slot-value lambda 'rest-arg)
			     (slot-value lambda 'has-keys))
		     (gensym "REST"))))
    (flet ((bind-variable (name init)
	     (cond ((symbolp name)
		    (setf (cdr tail) (cons `(progv '(name) (list ,init)) nil)
			  tail (last (cadr tail))))
		   ((member name local-vars)
		    (setf (cdr tail) (cons `(setf ,(slot-value name 'symbol) ,init) nil)
			  tail (cdr tail)))
		   (t
		    (setf (cdr tail) (cons `(setf (svref *env* ,(1+ (position name env-vars))) ,init) nil)
			  tail (cdr tail))))))
      ;; Required args.
      (iter (for name in (slot-value lambda 'required-args))
	    (let ((sym (gensym (if (symbolp name)
				   (symbol-name name)
				   (symbol-name (slot-value name 'name))))))
	      (push sym new-ll)
	      (if (member name local-vars)
		  (setf (slot-value name 'symbol) sym)
		  (bind-variable name sym))))
      ;; Optional args.
      (push '&optional new-ll)
      (iter (for (name init-form suppliedp) in (slot-value lambda 'optional-args))
	    (let* ((sym (gensym (if (symbolp name)
				    (symbol-name name)
				    (symbol-name (slot-value name 'name)))))
		   (supplied-sym (if (eql suppliedp nil)
				     (gensym (format nil "~A-SUPPLIED-P" (symbol-name sym)))
				     (gensym (if (symbolp suppliedp)
						 (symbol-name suppliedp)
						 (symbol-name (slot-value suppliedp 'name)))))))
	      (push (list sym 'nil supplied-sym) new-ll)
	      (when (member name local-vars)
		(setf (slot-value name 'symbol) sym))
	      (bind-variable name `(if ,supplied-sym
				       ,sym
				       ,(translate-form init-form env)))
	      (unless (eql suppliedp nil)
		(when (member suppliedp local-vars)
		  (setf (slot-value suppliedp 'symbol) supplied-sym))
		(bind-variable suppliedp `(if ,supplied-sym ',(genesis-intern "T") 'nil)))))
      ;; Rest args.
      (when rest-sym
	(push '&rest new-ll)
	(push rest-sym new-ll)
	(push '&aux new-ll)
	(with-slots (rest-arg) lambda
	  (when rest-arg
	    (let ((sym (gensym (if (symbolp rest-arg)
				   (symbol-name rest-arg)
				   (symbol-name (slot-value rest-arg 'name))))))
	      (push (list sym rest-sym) new-ll)
	      (if (member rest-arg local-vars)
		  (setf (slot-value rest-arg 'symbol) sym)
		  (bind-variable rest-arg sym))))))
      ;; Keywords.
      ;; Rest sym has already been added, so has &aux.
      (when (slot-value lambda 'has-keys)
	;; TODO: validate keywords.
	(dolist (k (slot-value lambda 'key-args))
	  (let* ((keyword (caar k))
		 (var (cadar k))
		 (init-form (cadr k))
		 (suppliedp (caddr k))
		 (sym (gensym (symbol-name (if (symbolp var)
						var
						(slot-value var 'name)))))
		 (x (gensym)))
	    (push (list sym `(let ((,x (member ',keyword ,rest-sym)))
			       (if ,x
				   (cadr ,x)
				   ,(translate-form init-form env))))
		  new-ll)
	    (if (member var local-vars)
		(setf (slot-value var 'symbol) sym)
		(bind-variable var sym))
	    (unless (eql suppliedp nil)
	      (let ((sym (gensym (symbol-name (if (symbolp suppliedp)
						   suppliedp
						   (slot-value suppliedp 'name))))))
		(push (list sym `(if (member ',keyword ,rest-sym)
				     ',(genesis-intern "T")
				     'nil))
		      new-ll)
		(if (member suppliedp local-vars)
		    (setf (slot-value suppliedp 'symbol) sym)
		    (bind-variable suppliedp sym)))))))
      ;; Aux args. TODO!
      (when (slot-value lambda 'aux-args)
	(error "TODO: aux args."))
      (setf (cdr tail) (cons (translate-implicit-progn (slot-value lambda 'body) env) nil))
      `(flet ((,name ,(nreverse new-ll)
		,@(when (slot-value lambda 'key-args)
		    (let ((keywords (mapcar #'caar (slot-value lambda 'key-args)))
			  (barf (gensym)))
		      (if (slot-value lambda 'allow-other-keys)
			  (list `(when (oddp (list-length ,rest-sym))
				   (error "Odd number of keyword arguments.")))
			  (list `(progn
				   (when (oddp (list-length ,rest-sym))
				     (error "Odd number of keyword arguments."))
				   (unless (cadr (member ',(genesis-intern "ALLOW-OTHER-KEYS" t) ,rest-sym))
				     (do ((,barf ,rest-sym (cddr ,barf)))
					 ((null ,barf))
				       (unless (member (car ,barf) ',keywords)
					 (error "Invalid keyword ~S. Wanted one of ~S." (car ,barf) ',keywords)))))))))
		,(if env-vars
		     `(let ((old-env *env*)
			    (*env* (make-array ,(1+ (length env-vars)))))
			(setf (svref *env* 0) old-env)
			,@(cdr lambda-body))
		     `(progn ,@(cdr lambda-body)))))
	 #',name))))

;;; Support functions & macros.
(declaim (inline genesis-close-environment))

(defvar *function-info* (make-hash-table :weakness :key))

(defun genesis-close-environment (lambda env source source-env)
  (cond (env (let ((fn (lambda (&rest args)
			 (let ((*env* env))
			   (apply lambda args)))))
	       (setf (gethash fn *function-info*) (list lambda env))
	       (setf (gethash lambda *function-info*) (list source source-env nil))
	       fn))
	(t (setf (gethash lambda *function-info*) (list source source-env nil))
	   lambda)))

(defun genesis-eval (form)
  ;; Bind over *STANDARD-INPUT* and *STANDARD-OUTPUT* before calling.
  ;; They are bound instead of set so that the host streams don't get
  ;; caught by dump.
  (progv
      (list (genesis-intern "*STANDARD-INPUT*") (genesis-intern "*STANDARD-OUTPUT*"))
      (list *standard-input* *standard-output*)
    (funcall (eval (translate-lambda (pass1-lambda (list (genesis-intern "LAMBDA") '()
							  (list (genesis-intern "PROGN") form))
						   nil)
				     nil)))))
