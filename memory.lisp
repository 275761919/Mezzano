;;;; Memory Memory Memory handling.
;;;; Physical memory tracking and page tables fiddling.

(in-package #:sys.int)

(defvar *physical-memory-info*)
(defvar *multiboot-modules*)

(declaim (special *multiboot-info* *multiboot-header*))

(defconstant +multiboot-flag-mem-info+     #b00000001)
(defconstant +multiboot-flag-boot-device+  #b00000010)
(defconstant +multiboot-flag-command-line+ #b00000100)
(defconstant +multiboot-flag-modules+      #b00001000)
(defconstant +multiboot-flag-aout-symbols+ #b00010000)
(defconstant +multiboot-flag-elf-symbols+  #b00100000)
(defconstant +multiboot-flag-memory-map+   #b01000000)

(defconstant +multiboot-flags+ 0)
(defconstant +multiboot-mem-lower+ 1)
(defconstant +multiboot-mem-upper+ 2)
(defconstant +multiboot-boot-device+ 3)
(defconstant +multiboot-command-line+ 4)
(defconstant +multiboot-module-count+ 5)
(defconstant +multiboot-module-address+ 6)
(defconstant +multiboot-mmap-length+ 11)
(defconstant +multiboot-mmap-address+ 12)
(defconstant +multiboot-drives-length+ 13)
(defconstant +multiboot-drives-address+ 14)
(defconstant +multiboot-config-table+ 15)
(defconstant +multiboot-boot-loader-name+ 16)
(defconstant +multiboot-apm-table+ 17)

(defun e820-memory-type (type)
  "Convert an E820 memory type to a normal memory type."
  (case type
    (1 :free)
    (t :reserved)))

(defun read-memory-map ()
  (let ((memory-map (make-array 16 :adjustable t :fill-pointer 0))
        (flags (memref-unsigned-byte-32 (+ *multiboot-info* #x8000000000) +multiboot-flags+)))
    ;; Parse the multiboot memory info.
    (cond ((logtest flags +multiboot-flag-memory-map+)
           (do ((length (memref-unsigned-byte-32 (+ *multiboot-info* #x8000000000) +multiboot-mmap-length+))
                (mmap (+ (memref-unsigned-byte-32 (+ *multiboot-info* #x8000000000) +multiboot-mmap-address+) #x8000000000)
                      (+ mmap (memref-unsigned-byte-32 mmap 0) 4)))
               ((>= mmap (+ (memref-unsigned-byte-32 (+ *multiboot-info* #x8000000000) +multiboot-mmap-address+) #x8000000000 length)))
             (let ((base (memref-unsigned-byte-64 (+ mmap 4) 0))
                   (length (memref-unsigned-byte-64 (+ mmap 4 8) 0))
                   (type (e820-memory-type (memref-unsigned-byte-32 (+ mmap 4 16) 0))))
               (vector-push-extend (list base length type) memory-map))))
          ((logtest flags +multiboot-flag-mem-info+)
           (vector-push-extend (list #x100000 (* (memref-unsigned-byte-32 (+ *multiboot-info* #x8000000000) +multiboot-mem-upper+)
                                                 1024)
                                     :free)
                               memory-map))
          (t (error "Bootloader did not supply memory information.")))
    ;; Examine the multiboot header to figure out how large the kernel is and add that in.
    (vector-push-extend (list (aref *multiboot-header* 4)
                              (- (cond ((not (zerop (aref *multiboot-header* 6)))
                                        (aref *multiboot-header* 6))
                                       (t (aref *multiboot-header* 5)))
                                 (aref *multiboot-header* 4))
                              :kernel)
                        memory-map)
    ;; Add each multiboot module.
    (when (logtest flags +multiboot-flag-modules+)
      (let ((module-count (memref-unsigned-byte-32 (+ *multiboot-info* #x8000000000) 5))
            (module-base (+ #x8000000000 (memref-unsigned-byte-32 (+ *multiboot-info* #x8000000000) 6))))
        (dotimes (i module-count)
          (let* ((start (memref-unsigned-byte-32 (+ module-base (* i 32)) 0))
                 (end (memref-unsigned-byte-32 (+ module-base (* i 32)) 1))
                 (length (- end start)))
          (vector-push-extend (list start length :module) memory-map)))))
    ;; Round addresses and lengths to page boundaries.
    ;; Free memory ranges get shrunk, other ranges are grown.
    (dotimes (i (length memory-map))
      (let ((range (aref memory-map i)))
        (case (third range)
          (:free (unless (zerop (logand (first range) #xFFF))
                   (setf (first range) (+ (logand (first range) (lognot #xFFF))
                                          #x1000)))
                 (unless (zerop (logand (second range) #xFFF))
                   (setf (second range) (logand (second range) (lognot #xFFF)))))
          (t (unless (zerop (logand (first range) #xFFF))
               (setf (first range) (logand (first range) (lognot #xFFF))))
             (unless (zerop (logand (second range) #xFFF))
               (setf (second range) (+ (logand (second range) (lognot #xFFF))
                                       #x1000)))))))
    ;; Split overlapping regions.
    (do ((saw-overlap t))
        ((not saw-overlap))
      (setf saw-overlap nil)
      #+nil(delete-if 'zerop memory-map :key 'second)
      ;; Remove zero-size areas.
      (let ((new (make-array (length memory-map) :adjustable t :fill-pointer 0)))
        (dotimes (i (length memory-map))
          (unless (zerop (second (aref memory-map i)))
            (vector-push-extend (aref memory-map i) new)))
        (setf memory-map new))
      ;; Sort before scanning.
      (setf memory-map (sort memory-map '< :key 'first))
      (dotimes (i (1- (length memory-map)))
        (let ((a (aref memory-map i))
              (b (aref memory-map (1+ i))))
          (when (< (first b) (+ (first a) (second a)))
            (setf saw-overlap t)
            ;; Overlap. Figure out which region to split.
            (cond ((eql (third a) :free)
                   (cond ((eql (first a) (first b))
                          (setf (second a) (max 0 (- (+ (first b) (second b)) (+ (first a) (second a))))
                                (first a) (+ (first b) (second b))))
                         (t (vector-push-extend (list (+ (first b) (second b)) (max 0 (- (+ (first a) (second a)) (+ (first b) (second b)))) :free)
                                                memory-map)
                            (setf (second a) (- (first b) (first a))))))
                  (t ???))
            (format t "~S overlaps with ~S~%" a b)))))

    (dotimes (i (length memory-map))
      (format t "~3D: ~16,'0,'_,4:X ~16,'0,'_,4:X  ~A~%" i
              (first (aref memory-map i))
              (+ (first (aref memory-map i))
                 (second (aref memory-map i)))
              (third (aref memory-map i))))
    memory-map))

(define-lap-function %%page-fault ()
  (sys.lap-x86:push :rax)
  (sys.lap-x86:push :rbx)
  (sys.lap-x86:push :rcx)
  (sys.lap-x86:push :rdx)
  (sys.lap-x86:push :rbp)
  (sys.lap-x86:push :rsi)
  (sys.lap-x86:push :rdi)
  (sys.lap-x86:push :r8)
  (sys.lap-x86:push :r9)
  (sys.lap-x86:push :r10)
  (sys.lap-x86:push :r11)
  (sys.lap-x86:push :r12)
  (sys.lap-x86:push :r13)
  (sys.lap-x86:push :r14)
  (sys.lap-x86:push :r15)
  (sys.lap-x86:mov64 :r8 :rsp)
  (sys.lap-x86:shl64 :r8 3)
  (sys.lap-x86:test64 :rsp #b1000)
  (sys.lap-x86:jz already-aligned)
  (sys.lap-x86:push 0)
  already-aligned
  (sys.lap-x86:mov32 :ecx 8)
  ;; FIXME: Should switch to a secondary data stack.
  (sys.lap-x86:mov64 :r13 (:constant ldb-exception))
  (sys.lap-x86:call (:symbol-function :r13))
  (sys.lap-x86:mov64 :rsp :r8)
  (sys.lap-x86:pop :r15)
  (sys.lap-x86:pop :r14)
  (sys.lap-x86:pop :r13)
  (sys.lap-x86:pop :r12)
  (sys.lap-x86:pop :r11)
  (sys.lap-x86:pop :r10)
  (sys.lap-x86:pop :r9)
  (sys.lap-x86:pop :r8)
  (sys.lap-x86:pop :rdi)
  (sys.lap-x86:pop :rsi)
  (sys.lap-x86:pop :rbp)
  (sys.lap-x86:pop :rdx)
  (sys.lap-x86:pop :rcx)
  (sys.lap-x86:pop :rbx)
  (sys.lap-x86:pop :rax)
  (sys.lap-x86:add64 :rsp 16)
  (sys.lap-x86:iret))

(set-idt-entry 14 :offset (lisp-object-address #'%%page-fault))
