;;;; John McCarthy 1927-2011

(in-package #:system.compiler)

(defparameter *suppress-builtins* nil
  "When T, the built-in functions will not be used and full calls will
be generated instead.")

(defvar *run-counter* nil)
(defvar *load-list* nil)
(defvar *r8-value* nil)
(defvar *stack-values* nil)
(defvar *for-value* nil)
(defvar *rename-list* nil)
(defvar *code-accum* nil)
(defvar *trailers* nil)
(defvar *environment* nil)
(defvar *environment-chain* nil)
(defvar *special-bindings* nil)
(defvar *current-lambda-name* nil)
(defvar *control-stack-depth* nil)

(defun emit (&rest instructions)
  (dolist (i instructions)
    (push i *code-accum*)))

(defmacro emit-trailer ((&optional name) &body body)
  `(push (let ((*code-accum* '()))
	   ,(when name
		  `(emit ,name))
	   (progn ,@body)
	   (nreverse *code-accum*))
	 *trailers*))

(defun fixnum-to-raw (integer)
  (check-type integer (signed-byte 61))
  (* integer 8))

(defun character-to-raw (character)
  (check-type character character)
  (logior (ash (char-int character) 4) 10))

(defun control-stack-frame-offset (slot)
  "Convert a control stack slot number to an offset."
  (- (* (+ slot 4) 8)))

(defun control-stack-slot-ea (slot)
  "Return an effective address for a control stack slot."
  `(:cfp ,(control-stack-frame-offset slot)))

;;; TODO: This should work on a stack-like system so that slots can be
;;; reused when the allocation is no longer needed.
(defun allocate-control-stack-slots (count)
  (when (oddp count) (incf count))
  (incf *control-stack-depth* count))

(defun codegen-lambda (lambda)
  (let* ((*current-lambda* lambda)
         (*current-lambda-name* (or (lambda-information-name lambda)
                                    (list 'lambda :in *current-lambda-name*)))
         (*run-counter* 0)
         (*load-list* '())
         (*r8-value* nil)
         (*stack-values* (make-array 8 :fill-pointer 0 :adjustable t))
         (*for-value* t)
         (*rename-list* '())
         (*code-accum* '())
         (*trailers* '())
         (arg-registers '(:r8 :r9 :r10 :r11 :r12))
         (*environment-chain* '())
         (*environment* *environment*)
         (*special-bindings* '())
         (*control-stack-depth* 0))
    (when (or (lambda-information-enable-keys lambda)
              (lambda-information-key-args lambda))
      (error "&KEY arguments did not get lowered!"))
    ;; Save environment pointer.
    (when *environment*
      (let ((slot (find-stack-slot)))
        (setf (aref *stack-values* slot) (cons :environment :home))
        (push slot *environment-chain*)
        (emit `(sys.lap-x86:mov64 (:stack ,slot) :rbx))))
    (let ((env-size 0))
      ;; Count and place non-local lexical variables (environment size).
      (dolist (arg (lambda-information-required-args lambda))
        (when (and (lexical-variable-p arg)
                   (not (localp arg)))
          (incf env-size)))
      (dolist (arg (lambda-information-optional-args lambda))
        (when (and (lexical-variable-p (first arg))
                   (not (localp (first arg))))
          (incf env-size))
        (when (and (third arg)
                   (lexical-variable-p (third arg))
                   (not (localp (third arg))))
          (incf env-size)))
      (when (and (lambda-information-rest-arg lambda)
                 (lexical-variable-p (lambda-information-rest-arg lambda))
                 (not (localp (lambda-information-rest-arg lambda))))
        (incf env-size))
      (unless (zerop env-size)
        (push '() *environment*)
        ;; Allocate an environment frame.
        ;; TODO: Escape analysis for dynamic extent.
        ;; Ughhhh. Save all registers.
        (emit `(sys.lap-x86:mov64 (:lsp -8) nil)
              `(sys.lap-x86:mov64 (:lsp -16) nil)
              `(sys.lap-x86:mov64 (:lsp -24) nil)
              `(sys.lap-x86:mov64 (:lsp -32) nil)
              `(sys.lap-x86:mov64 (:lsp -40) nil)
              `(sys.lap-x86:mov64 (:lsp -48) nil)
              `(sys.lap-x86:mov64 (:lsp -56) nil)
              `(sys.lap-x86:sub64 :lsp 56)
              `(sys.lap-x86:mov64 (:lsp 0) :r8)
              `(sys.lap-x86:mov64 (:lsp 8) :r9)
              `(sys.lap-x86:mov64 (:lsp 16) :r10)
              `(sys.lap-x86:mov64 (:lsp 24) :r11)
              `(sys.lap-x86:mov64 (:lsp 32) :r12)
              `(sys.lap-x86:mov64 (:lsp 40) :r13)
              `(sys.lap-x86:mov64 (:lsp 48) :rcx))
        (emit `(sys.lap-x86:mov64 :r13 (:constant sys.int::make-simple-vector))
              `(sys.lap-x86:mov32 :ecx 8)
              `(sys.lap-x86:mov32 :r8d ,(* (1+ env-size) 8))
              `(sys.lap-x86:call (:symbol-function :r13))
              `(sys.lap-x86:mov64 :lsp :rbx)
              `(sys.lap-x86:mov64 :rbx :r8))
        (when *environment-chain*
          (emit ;; Fetch saved environment link.
                `(sys.lap-x86:mov64 :r8 (:stack ,(first *environment-chain*)))
                `(sys.lap-x86:mov64 (:rbx 1) :r8)))
        ;; Restore registers
        (emit `(sys.lap-x86:mov64 :r8 (:lsp 0))
              `(sys.lap-x86:mov64 :r9 (:lsp 8))
              `(sys.lap-x86:mov64 :r10 (:lsp 16))
              `(sys.lap-x86:mov64 :r11 (:lsp 24))
              `(sys.lap-x86:mov64 :r12 (:lsp 32))
              `(sys.lap-x86:mov64 :r13 (:lsp 40))
              `(sys.lap-x86:mov64 :rcx (:lsp 48))
              `(sys.lap-x86:add64 :lsp 56))
        (let ((slot (find-stack-slot)))
          (setf (aref *stack-values* slot) (cons :environment :home))
          (push slot *environment-chain*)
          (emit `(sys.lap-x86:mov64 (:stack ,slot) :rbx))))
      ;; Store &REST arg before doing &OPTIONAL arguments to free up R13.
      ;; R13 will have to be spilled and reloaded when &REST is special.
      (let ((rest-arg (lambda-information-rest-arg lambda)))
        (when (and rest-arg
                   ;; Avoid generating code &REST code when the variable isn't used.
                   (not (and (lexical-variable-p rest-arg)
                             (zerop (lexical-variable-use-count rest-arg)))))
          (unless (lexical-variable-p rest-arg)
            (return-from codegen-lambda
              (sys.int::assemble-lap `((sys.lap-x86:mov64 :r13 (:constant error))
                                       (sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 1))
                                       (sys.lap-x86:mov64 :r8 (:constant "TODO: special variables. &REST"))
                                       (sys.lap-x86:call (:symbol-function :r13))
                                       (sys.lap-x86:ud2)))))
          (cond ((localp rest-arg)
                 (let ((ofs (find-stack-slot)))
                   (setf (aref *stack-values* ofs) (cons rest-arg :home))
                   (emit `(sys.lap-x86:mov64 (:stack ,ofs) :r13))))
                ((lexical-variable-p rest-arg)
                 ;; Non-local variable.
                 ;; +1 to align on the data. Backlink is skipped by magic.
                 (emit `(sys.lap-x86:mov64 :rbx (:stack ,(first *environment-chain*)))
                       `(sys.lap-x86:mov64 (:rbx ,(+ 1 (* (- env-size (length (first *environment*))) 8)))
                                           :r13))
                 (push rest-arg (first *environment*))))))
      ;; Compile argument setup code.
      (let ((current-arg-index 0))
        ;; Environemnt vector is in :RBX for required arguments.
        (dolist (arg (lambda-information-required-args lambda))
          (incf current-arg-index)
          (cond ((and (lexical-variable-p arg)
                      (localp arg))
                 (let ((ofs (find-stack-slot)))
                   (setf (aref *stack-values* ofs) (cons arg :home))
                   (if arg-registers
                       (emit `(sys.lap-x86:mov64 (:stack ,ofs) ,(pop arg-registers)))
                       (emit `(sys.lap-x86:mov64 :r8 (:lfp ,(* (- current-arg-index 6) 8)))
                             `(sys.lap-x86:mov64 (:stack ,ofs) :r8)))))
                ((lexical-variable-p arg)
                 ;; Non-local variable.
                 ;; +1 to align on the data. Backlink is skipped by magic.
                 (if arg-registers
                     (emit `(sys.lap-x86:mov64 (:rbx ,(+ 1 (* (- env-size (length (first *environment*))) 8)))
                                               ,(pop arg-registers)))
                     (emit `(sys.lap-x86:mov64 :r8 (:lfp ,(* (- current-arg-index 6) 8)))
                           `(sys.lap-x86:mov64 (:rbx ,(+ 1 (* (- env-size (length (first *environment*))) 8)))
                                               :r8)))
                 (push arg (first *environment*)))
                (t (return-from codegen-lambda
                     (sys.int::assemble-lap `((sys.lap-x86:mov64 :r13 (:constant error))
                                              (sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 1))
                                              (sys.lap-x86:mov64 :r8 (:constant "TODO: special required variables"))
                                              (sys.lap-x86:call (:symbol-function :r13))
                                              (sys.lap-x86:ud2)))))))
        ;; Need to load environment vector for optional args because the
        ;; initializer may trash :RBX.
        (dolist (arg (lambda-information-optional-args lambda))
          (when (or (not (lexical-variable-p (first arg)))
                    (and (third arg)
                         (not (lexical-variable-p (third arg)))))
            (return-from codegen-lambda
              (sys.int::assemble-lap `((sys.lap-x86:mov64 :r13 (:constant error))
                                       (sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 1))
                                       (sys.lap-x86:mov64 :r8 (:constant "TODO: special variables. &OPTIONAL"))
                                       (sys.lap-x86:call (:symbol-function :r13))
                                       (sys.lap-x86:ud2)))))
          (let ((mid-label (gensym))
                (end-label (gensym))
                (var-ofs nil)
                (sup-ofs nil))
            (when (localp (first arg))
              (setf var-ofs (find-stack-slot))
              (setf (aref *stack-values* var-ofs) (cons (first arg) :home)))
            (when (and (third arg)
                       (localp (third arg)))
              (setf sup-ofs (find-stack-slot))
              (setf (aref *stack-values* sup-ofs) (cons (third arg) :home)))
            ;; Check if this argument was supplied.
            (emit `(sys.lap-x86:cmp64 (:cfp -24) ,(fixnum-to-raw current-arg-index))
                  `(sys.lap-x86:jle ,mid-label))
            ;; Argument supplied, stash wherever.
            (cond (var-ofs
                   ;; Local var.
                   (if arg-registers
                       (emit `(sys.lap-x86:mov64 (:stack ,var-ofs) ,(pop arg-registers)))
                       (emit `(sys.lap-x86:mov64 :r8 (:lfp ,(* (- current-arg-index 5) 8)))
                             `(sys.lap-x86:mov64 (:stack ,var-ofs) :r8))))
                  (t ;; Non-local var. RBX will still be valid.
                   ;; +1 to align on the data. Backlink is skipped by magic.
                   (setf var-ofs (length (first *environment*)))
                   (if arg-registers
                       (emit `(sys.lap-x86:mov64 (:rbx ,(+ 1 (* (- env-size var-ofs) 8)))
                                                 ,(pop arg-registers)))
                       (emit `(sys.lap-x86:mov64 :r8 (:lfp ,(* (- current-arg-index 5) 8)))
                             `(sys.lap-x86:mov64 (:rbx ,(+ 1 (* (- env-size var-ofs) 8)))
                                                 :r8)))
                   (push (first arg) (first *environment*))))
            (when (third arg)
              (cond (sup-ofs
                     (emit `(sys.lap-x86:mov64 (:stack ,sup-ofs) t)))
                    (t ;; Non-local var. RBX will still be valid.
                     ;; +1 to align on the data. Backlink is skipped by magic.
                     (setf sup-ofs (length (first *environment*)))
                     (emit `(sys.lap-x86:mov64 (:rbx ,(+ 1 (* (- env-size sup-ofs) 8)))
                                               ,t))
                     (push (third arg) (first *environment*)))))
            (emit `(sys.lap-x86:jmp ,end-label)
                  mid-label)
            ;; Argument not supplied. Evaluate init-form.
            (let ((tag (cg-form (second arg))))
              (load-in-r8 tag t)
              (setf *r8-value* nil)
              ;; Possibly reload the environment.
              (when (or (not (localp (first arg)))
                        (and (third arg)
                             (not (localp (third arg)))))
                (emit `(sys.lap-x86:mov64 :rbx (:stack ,(first *environment-chain*)))))
              (cond ((localp (first arg))
                     ;; Local var.
                     (emit `(sys.lap-x86:mov64 (:stack ,var-ofs) :r8)))
                    (t ;; Non-local var. RBX will still be valid.
                     ;; +1 to align on the data. Backlink is skipped by magic.
                     (emit `(sys.lap-x86:mov64 (:rbx ,(+ 1 (* (- env-size var-ofs) 8)))
                                               ,:r8))))
              (when (third arg)
                (cond ((localp (third arg))
                       (emit `(sys.lap-x86:mov64 (:stack ,sup-ofs) nil)))
                      (t ;; Non-local var. RBX will still be valid.
                       ;; +1 to align on the data. Backlink is skipped by magic.
                       (emit `(sys.lap-x86:mov64 (:rbx ,(+ 1 (* (- env-size sup-ofs) 8)))
                                               ,t))))))
            (emit end-label)
            (incf current-arg-index)))))
    (let* ((code-tag (let ((*for-value* :multiple))
                       (cg-form `(progn ,@(lambda-information-body lambda)))))
           (req-count (length (lambda-information-required-args lambda)))
           (opt-count (length (lambda-information-optional-args lambda)))
           (arg-count (+ req-count opt-count))
           (stack-arg-count (max 0 (- arg-count 5))))
      (when code-tag
        (unless (eql code-tag :multiple)
          (load-in-r8 code-tag t)
          (emit `(sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 1))))
        (cond ((and (plusp stack-arg-count)
                    (zerop opt-count)
                    (not (lambda-information-rest-arg lambda)))
               ;; More than 5 required arguments, no &OPTIONAL or &REST.
               (emit `(sys.lap-x86:lea64 :rbx (:lfp ,(* stack-arg-count 8)))))
              ((or (and (plusp stack-arg-count)
                        (plusp opt-count))
                   (lambda-information-rest-arg lambda))
               ;; Many &OPTIONAL args or a &REST arg supplied. Do the full-fat pop.
               (emit `(sys.lap-x86:mov64 :rax (:cfp -24))
                     `(sys.lap-x86:xor32 :edx :edx)
                     `(sys.lap-x86:sub64 :rax ,(* 8 5))
                     `(sys.lap-x86:cmov64ng :rax :rdx)
                     `(sys.lap-x86:lea64 :rbx (:lfp :rax))))
              (t ;; 5 or fewer arguments, no &REST.
               (emit `(sys.lap-x86:mov64 :rbx :lfp))))
        (emit `(sys.lap-x86:mov64 :lfp (:cfp -8)))
        (emit `(sys.lap-x86:leave)
              `(sys.lap-x86:ret))))
    (sys.int::assemble-lap (nconc
			    (generate-entry-code lambda)
			    (nreverse *code-accum*)
			    (apply #'nconc *trailers*))
                           *current-lambda-name*)))

(defun generate-entry-code (lambda)
  (let ((entry-label (gensym "ENTRY"))
	(invalid-arguments-label (gensym "BADARGS")))
    (push (list `(sys.lap-x86:ud2)
                invalid-arguments-label
		`(sys.lap-x86:mov64 :r13 (:constant sys.int::%invalid-argument-error))
		`(sys.lap-x86:call (:symbol-function :r13)))
	  *trailers*)
    (nconc
     (list entry-label
	   ;; Create control stack frame.
	   `(sys.lap-x86:push :cfp)
	   `(sys.lap-x86:mov64 :cfp :csp)
	   ;; Save old LFP.
	   `(sys.lap-x86:push :lfp)
	   ;; Function object.
	   `(sys.lap-x86:lea64 :rax (:rip ,entry-label))
	   `(sys.lap-x86:push :rax)
	   ;; Saved argument count.
	   `(sys.lap-x86:push :rcx)
	   ;; Adjust CSP. 1+ for alignment (also used by the rest code).
           `(sys.lap-x86:sub64 :csp ,(* (1+ *control-stack-depth*) 8)))
     ;; Emit the argument count test.
     (cond ((lambda-information-rest-arg lambda)
	    ;; If there are no required parameters, then don't generate a lower-bound check.
	    (when (lambda-information-required-args lambda)
	      ;; Minimum number of arguments.
	      (list `(sys.lap-x86:cmp32 :ecx ,(fixnum-to-raw (length (lambda-information-required-args lambda))))
		    `(sys.lap-x86:jl ,invalid-arguments-label))))
	   ((and (lambda-information-required-args lambda)
		 (lambda-information-optional-args lambda))
	    ;; A range.
	    (list `(sys.lap-x86:sub32 :ecx ,(fixnum-to-raw (length (lambda-information-required-args lambda))))
		  `(sys.lap-x86:cmp32 :ecx ,(fixnum-to-raw (length (lambda-information-optional-args lambda))))
		  `(sys.lap-x86:ja ,invalid-arguments-label)))
	   ((lambda-information-optional-args lambda)
	    ;; Maximum number of arguments.
	    (list `(sys.lap-x86:cmp32 :ecx ,(fixnum-to-raw (length (lambda-information-optional-args lambda))))
		  `(sys.lap-x86:ja ,invalid-arguments-label)))
	   ((lambda-information-required-args lambda)
	    ;; Exact number of arguments.
	    (list `(sys.lap-x86:cmp32 :ecx ,(fixnum-to-raw (length (lambda-information-required-args lambda))))
		  `(sys.lap-x86:jne ,invalid-arguments-label)))
	   ;; No arguments
	   (t (list `(sys.lap-x86:test32 :ecx :ecx)
		    `(sys.lap-x86:jnz ,invalid-arguments-label))))
     (when (and (lambda-information-rest-arg lambda)
                ;; Avoid generating code &REST code when the variable isn't used.
                (not (and (lexical-variable-p (lambda-information-rest-arg lambda))
                          (zerop (lexical-variable-use-count (lambda-information-rest-arg lambda))))))
       (let ((regular-argument-count (+ (length (lambda-information-required-args lambda))
					(length (lambda-information-optional-args lambda))))
	     (rest-loop-head (gensym "REST-LOOP-HEAD"))
	     (rest-loop-test (gensym "REST-LOOP-TEST"))
             (dx-rest (lexical-variable-dynamic-extent (lambda-information-rest-arg lambda))))
	 ;; Assemble the rest list into r13.
	 (nconc
	  ;; Push all argument registers and create two scratch stack slots.
	  ;; Eight total slots.
	  ;; This should be clamped to the actual number of arguments
	  ;; but it doesn't really matter.
	  (let ((result '()))
	    (dotimes (i 8 result)
	      (push `(sys.lap-x86:mov64 (:lsp ,(- (* (1+ i) 8))) nil) result)))
	  (list `(sys.lap-x86:sub64 :lsp ,(* 8 8)))
	  (let ((i 1))
	    (mapcar #'(lambda (x)
			`(sys.lap-x86:mov64 (:lsp ,(* (incf i) 8)) ,x))
		    '(:rbx :r8 :r9 :r10 :r11 :r12)))
	  (list
	   ;; Number of arguments processed.
	   `(sys.lap-x86:mov64 (:cfp -32) ,(fixnum-to-raw regular-argument-count)))
	   ;; Create the result cell.
          (cond
            (dx-rest
             (list `(sys.lap-x86:sub64 :csp 16)
                   `(sys.lap-x86:mov64 (:csp 0) nil)
                   `(sys.lap-x86:mov64 (:csp 8) nil)
                   `(sys.lap-x86:lea64 :r8 (:csp 1))))
            (t
             (list `(sys.lap-x86:mov64 :r8 nil)
                   `(sys.lap-x86:mov64 :r9 :r8)
                   `(sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 2))
                   `(sys.lap-x86:mov64 :r13 (:constant cons))
                   `(sys.lap-x86:call (:symbol-function :r13))
                   `(sys.lap-x86:mov64 :lsp :rbx))))
          (list
           ;; Stash in the result slot and the scratch slot.
           `(sys.lap-x86:mov64 (:lsp) :r8)
	   `(sys.lap-x86:mov64 (:lsp 8) :r8)
	   ;; Now walk the arguments, adding to the list.
	   `(sys.lap-x86:mov64 :rax (:cfp -32))
	   `(sys.lap-x86:jmp ,rest-loop-test)
	   rest-loop-head)
          ;; Create a new cons.
          (cond
            (dx-rest
             (list `(sys.lap-x86:sub64 :csp 16)
                   `(sys.lap-x86:mov64 (:csp 0) nil)
                   `(sys.lap-x86:mov64 (:csp 8) nil)
                   `(sys.lap-x86:lea64 :r8 (:csp 1))
                   `(sys.lap-x86:mov64 :r9 (:lsp :rax 24))
                   `(sys.lap-x86:add64 :rax ,(fixnum-to-raw 1))
                   `(sys.lap-x86:mov64 (:cfp -32) :rax)
                   `(sys.lap-x86:mov64 (:car :r8) :r9)))
            (t
             (list `(sys.lap-x86:mov64 :r8 (:lsp :rax 24))
                   `(sys.lap-x86:mov64 :r9 nil)
                   `(sys.lap-x86:add64 :rax ,(fixnum-to-raw 1))
                   `(sys.lap-x86:mov64 (:cfp -32) :rax)
                   `(sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 2))
                   `(sys.lap-x86:mov64 :r13 (:constant cons))
                   `(sys.lap-x86:call (:symbol-function :r13))
                   `(sys.lap-x86:mov64 :lsp :rbx))))
          (list
	   `(sys.lap-x86:mov64 :r9 (:lsp))
	   `(sys.lap-x86:mov64 (:cdr :r9) :r8)
	   `(sys.lap-x86:mov64 (:lsp) :r8)
	   `(sys.lap-x86:mov64 :rax (:cfp -32))
	   rest-loop-test
	   `(sys.lap-x86:cmp64 :rax (:cfp -24))
	   `(sys.lap-x86:jl ,rest-loop-head)
	   ;; The rest list has been created!
	   ;; Now store it in R13 and restore the other registers.
	   `(sys.lap-x86:mov64 :r13 (:lsp 8))
	   `(sys.lap-x86:mov64 :r13 (:cdr :r13))
	   `(sys.lap-x86:mov64 :rbx (:lsp 16))
	   `(sys.lap-x86:mov64 :r8 (:lsp 24))
	   `(sys.lap-x86:mov64 :r9 (:lsp 32))
	   `(sys.lap-x86:mov64 :r10 (:lsp 40))
	   `(sys.lap-x86:mov64 :r11 (:lsp 48))
	   `(sys.lap-x86:mov64 :r12 (:lsp 56))
	   ;; Pop all the arguments off and the two scrach slots.
	   `(sys.lap-x86:add64 :lsp ,(* 8 8))))))
     ;; No arguments on the stack at this point.
     (list `(sys.lap-x86:mov64 :lfp :lsp))
     ;; Flush stack slots.
     (let ((result '()))
       (dotimes (i (length *stack-values*) result)
	 (push `(sys.lap-x86:mov64 (:lfp ,(- (* (1+ i) 8))) nil) result)))
     (unless (zerop (length *stack-values*))
       (list `(sys.lap-x86:sub64 :lsp ,(* (length *stack-values*) 8)))))))

(defun cg-form (form)
  (flet ((save-tag (tag)
	   (when (and tag *for-value* (not (keywordp tag)))
	     (push tag *load-list*))
	   tag))
    (etypecase form
      (cons (case (first form)
	      ((block) (save-tag (cg-block form)))
	      ((go) (cg-go form))
	      ((if) (save-tag (cg-if form)))
	      ((let) (cg-let form))
	      ((load-time-value) (cg-load-time-value form))
	      ((multiple-value-bind) (save-tag (cg-multiple-value-bind form)))
	      ((multiple-value-call) (save-tag (cg-multiple-value-call form)))
	      ((multiple-value-prog1) (cg-multiple-value-prog1 form))
	      ((progn) (cg-progn form))
	      ((progv) (cg-progv form))
	      ((quote) (cg-quote form))
	      ((return-from) (cg-return-from form))
	      ((setq) (cg-setq form))
	      ((tagbody) (cg-tagbody form))
	      ((the) (cg-the form))
	      ((unwind-protect) (cg-unwind-protect form))
	      (t (save-tag (cg-function-form form)))))
      (lexical-variable
       (save-tag (cg-variable form)))
      (lambda-information
       (let ((tag (cg-lambda form)))
         (when (and (consp tag)
                    (symbolp (car tag))
                    (null (cdr tag))
                    (not (eql 'quote (car tag))))
           (save-tag tag))
         tag)))))

(defun cg-block (form)
  (let* ((info (second form))
         (exit-label (gensym "block"))
         (escapes (not (localp info)))
         (*special-bindings* *special-bindings*)
         (*environment* *environment*)
         (*environment-chain* *environment-chain*)
         ;; Allowing predicate values here is too complicated when dealing with
         ;; non-local returns.
         (*for-value* (if (and escapes (eql *for-value* :predicate)) t *for-value*)))
    (setf (block-information-return-mode info) (if (eql *for-value* :predicate) t *for-value*)
          (block-information-count info) 0)
    (when escapes
      (smash-r8)
      ;; Allocate an environment for the tagbody.
      (emit `(sys.lap-x86:mov64 :r13 (:constant sys.int::make-simple-vector))
            `(sys.lap-x86:mov32 :ecx 8)
            `(sys.lap-x86:mov32 :r8d ,(* 2 8)) ; Backlink & pointer.
            `(sys.lap-x86:call (:symbol-function :r13))
            `(sys.lap-x86:mov64 :lsp :rbx))
      (when *environment-chain*
        ;; Set back-link.
        (emit `(sys.lap-x86:mov64 :r9 (:stack ,(first *environment-chain*)))
              `(sys.lap-x86:mov64 (:r8 1) :r9)))
      (let ((slot (find-stack-slot))
            (control-info (allocate-control-stack-slots 6)))
        ;; Construct jump info.
        (emit `(sys.lap-x86:lea64 :rax (:rip ,exit-label))
              `(sys.lap-x86:mov64 ,(control-stack-slot-ea control-info) :rax)
              `(sys.lap-x86:gs)
              `(sys.lap-x86:mov64 :rax (,+binding-stack-gs-offset+))
              `(sys.lap-x86:mov64 ,(control-stack-slot-ea (- control-info 1)) :rax)
              `(sys.lap-x86:mov64 ,(control-stack-slot-ea (- control-info 2)) :csp)
              `(sys.lap-x86:mov64 ,(control-stack-slot-ea (- control-info 3)) :cfp)
              `(sys.lap-x86:mov64 ,(control-stack-slot-ea (- control-info 4)) :lsp)
              `(sys.lap-x86:mov64 ,(control-stack-slot-ea (- control-info 5)) :lfp)
              ;; Save in the environment.
              `(sys.lap-x86:lea64 :rax ,(control-stack-slot-ea control-info))
              `(sys.lap-x86:mov64 (:r8 9) :rax))
        (setf (aref *stack-values* slot) (cons :environment :home))
        (push slot *environment-chain*)
        (emit `(sys.lap-x86:mov64 (:stack ,slot) :r8))
        (push (list (second form)) *environment*)
        (push (cons (list slot 2) :tagbody-or-block) *special-bindings*)
        (emit `(sys.lap-x86:gs)
              `(sys.lap-x86:sub64 (,+binding-stack-gs-offset+) 16)
              `(sys.lap-x86:gs)
              `(sys.lap-x86:mov64 :rax (,+binding-stack-gs-offset+))
              `(sys.lap-x86:mov64 (:rax 8) 8)
              `(sys.lap-x86:mov64 (:rax 0) :r8))))
    (let* ((*rename-list* (cons (list (second form) exit-label *special-bindings*) *rename-list*))
           (stack-slots (set-up-for-branch))
           (tag (cg-form `(progn ,@(cddr form)))))
      (cond ((and *for-value* tag (/= (block-information-count info) 0))
             ;; Returning a value, exit is reached normally and there were return-from forms reached.
             (let ((return-mode nil))
               (case *for-value*
                 (:predicate
                  (cond ((keywordp tag)
                         (load-predicate tag))
                        (t (load-in-r8 tag t)
                           (smash-r8)))
                  (setf return-mode (list (gensym))))
                 (:multiple
                  (unless (eql tag :multiple)
                    (load-multiple-values tag)
                    (smash-r8))
                  (setf return-mode :multiple))
                 (t (load-in-r8 tag t)
                    (smash-r8)
                    (setf return-mode (list (gensym)))))
               (when escapes
                 ;; Disable the tagbody and pop the binding stack.
                 (emit `(sys.lap-x86:mov64 (:lsp -8) nil)
                       `(sys.lap-x86:sub64 :lsp 8)
                       `(sys.lap-x86:mov64 (:lsp) :r8)
                       `(sys.lap-x86:mov64 :r8 (:stack ,(first *environment-chain*)))
                       `(sys.lap-x86:mov64 (:r8 9) nil)
                       `(sys.lap-x86:gs)
                       `(sys.lap-x86:mov64 :rax (,+binding-stack-gs-offset+))
                       `(sys.lap-x86:mov64 (:rax 0) 0)
                       `(sys.lap-x86:mov64 (:rax 8) 0)
                       `(sys.lap-x86:gs)
                       `(sys.lap-x86:add64 (,+binding-stack-gs-offset+) 16)
                       `(sys.lap-x86:mov64 :r8 (:lsp))
                       `(sys.lap-x86:add64 :lsp 8)))
               (emit exit-label)
               (setf *stack-values* (copy-stack-values stack-slots)
                     *r8-value* return-mode)))
            ((and *for-value* tag)
             ;; Returning a value, exit is reached normally, but no return-from forms were reached.
             (when escapes
               ;; Disable the tagbody and pop the binding stack.
               (smash-r8)
               (emit `(sys.lap-x86:mov64 :r8 (:stack ,(first *environment-chain*)))
                     `(sys.lap-x86:mov64 (:r8 9) nil)
                     `(sys.lap-x86:gs)
                     `(sys.lap-x86:mov64 :rax (,+binding-stack-gs-offset+))
                     `(sys.lap-x86:mov64 (:rax 0) 0)
                     `(sys.lap-x86:mov64 (:rax 8) 0)
                     `(sys.lap-x86:gs)
                     `(sys.lap-x86:add64 (,+binding-stack-gs-offset+) 16)))
             tag)
            ((and *for-value* (/= (block-information-count info) 0))
             ;; Returning a value, exit is not reached normally, but there were return-from forms reached.
             (smash-r8)
             (emit exit-label)
             (setf *stack-values* (copy-stack-values stack-slots)
                   *r8-value* (if (eql *for-value* :multiple)
                                  :multiple
                                  (list (gensym)))))
            ((/= (block-information-count info) 0)
             ;; Not returning a value, but there were return-from forms reached.
             (smash-r8)
             (when escapes
               ;; Disable the tagbody and pop the binding stack.
               (emit `(sys.lap-x86:mov64 :r8 (:stack ,(first *environment-chain*)))
                     `(sys.lap-x86:mov64 (:r8 9) nil)
                     `(sys.lap-x86:gs)
                     `(sys.lap-x86:mov64 :rax (,+binding-stack-gs-offset+))
                     `(sys.lap-x86:mov64 (:rax 0) 0)
                     `(sys.lap-x86:mov64 (:rax 8) 0)
                     `(sys.lap-x86:gs)
                     `(sys.lap-x86:add64 (,+binding-stack-gs-offset+) 16)))
             (emit exit-label)
             (setf *stack-values* (copy-stack-values stack-slots)
                   *r8-value* (list (gensym))))
            ;; No value returned, no return-from forms reached.
            (t nil)))))

(defun cg-go (form)
  (let ((tag (assoc (second form) *rename-list*)))
    (smash-r8)
    (cond (tag ;; Local jump.
           (let ((*for-value* nil))
             (unbind-to *special-bindings* (third tag)))
           (emit `(sys.lap-x86:jmp ,(second tag))))
          (t ;; Non-local exit, unwind required.
           (let ((invalid-go-tag (gensym)))
             (emit-trailer (invalid-go-tag)
               (load-constant :r8 (go-tag-name (second form)))
               (load-constant :r13 'sys.int::raise-bad-go-tag)
               (emit `(sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 1))
                     `(sys.lap-x86:call (:symbol-function :r13))
                     `(sys.lap-x86:ud2)))
             (multiple-value-bind (stack-slot depth offset)
                 (find-var (go-tag-tagbody (second form)) *environment* *environment-chain*)
               (emit `(sys.lap-x86:mov64 :r8 (:stack ,stack-slot)))
               (dotimes (n depth)
                 (emit `(sys.lap-x86:mov64 :r8 (:r8 1))))
               (emit `(sys.lap-x86:mov64 :r8 (:r8 ,(1+ (* (1+ offset) 8)))))
               ;; R8 holds the tagbody info, ensure it's still valid.
               (emit `(sys.lap-x86:cmp64 :r8 nil)
                     `(sys.lap-x86:je ,invalid-go-tag)
                     `(sys.lap-x86:mov64 :rax (:r8 8)))
               (unwind-to :rax nil)
               ;; Restore registers.
               (emit `(sys.lap-x86:mov64 :csp (:r8 16))
                     `(sys.lap-x86:mov64 :cfp (:r8 24))
                     `(sys.lap-x86:mov64 :lsp (:r8 32))
                     `(sys.lap-x86:mov64 :lfp (:r8 40))
                     ;; GO GO GO!
                     `(sys.lap-x86:mov64 :r8 (:r8 0))
                     `(sys.lap-x86:add64 :r8 (:r8 ,(* (position (second form)
                                                                (tagbody-information-go-tags
                                                                 (go-tag-tagbody (second form))))
                                                      8)))
                     `(sys.lap-x86:jmp :r8))))))
    'nil))

(defun branch-to (label))
(defun emit-label (label)
  (emit label))

(defun tag-saved-on-stack-p (tag)
  (dotimes (i (length *stack-values*) nil)
    (let ((x (aref *stack-values* i)))
      (when (or (eq tag x)
		(and (consp tag) (consp x)
		     (eql (car tag) (car x))
		     (eql (cdr tag) (cdr x))))
	(return t)))))

(defun set-up-for-branch ()
  ;; Save variables on the load list that might be modified to the stack.
  (smash-r8)
  (dolist (l *load-list*)
    (when (and (consp l) (lexical-variable-p (car l))
	       (not (eql (lexical-variable-write-count (car l)) 0)))
      ;; Don't save if there is something satisfying this already.
      (multiple-value-bind (loc true-tag)
	  (value-location l)
	(declare (ignore loc))
	(unless (tag-saved-on-stack-p true-tag)
	  (load-in-r8 l nil)
	  (smash-r8 t)))))
  (let ((new-values (make-array (length *stack-values*) :initial-contents *stack-values*)))
    ;; Now flush any values that aren't there to satisfy the load list.
    (dotimes (i (length new-values))
      (when (condemed-p (aref new-values i))
	(setf (aref new-values i) nil)))
    new-values))

(defun copy-stack-values (values)
  "Copy the VALUES array, ensuring that it's at least as long as the current *stack-values* and is adjustable."
  (let ((new (make-array (length *stack-values*) :adjustable t :fill-pointer t :initial-element nil)))
    (dotimes (i (length values))
      (setf (aref new i) (aref values i)))
    new))

;;; (predicate inverse jump-instruction cmov-instruction)
(defparameter *predicate-instructions*
  '((:o  :no  sys.lap-x86:jo   sys.lap-x86:cmov64o)
    (:no :o   sys.lap-x86:jno  sys.lap-x86:cmov64no)
    (:b  :nb  sys.lap-x86:jb   sys.lap-x86:cmov64b)
    (:nb :b   sys.lap-x86:jnb  sys.lap-x86:cmov64nb)
    (:c  :nc  sys.lap-x86:jc   sys.lap-x86:cmov64c)
    (:nc :c   sys.lap-x86:jnc  sys.lap-x86:cmov64nc)
    (:ae :nae sys.lap-x86:jae  sys.lap-x86:cmov64ae)
    (:nae :ae sys.lap-x86:jnae sys.lap-x86:cmov64nae)
    (:e  :ne  sys.lap-x86:je   sys.lap-x86:cmov64e)
    (:ne :e   sys.lap-x86:jne  sys.lap-x86:cmov64ne)
    (:z  :nz  sys.lap-x86:jz   sys.lap-x86:cmov64z)
    (:nz :z   sys.lap-x86:jnz  sys.lap-x86:cmov64nz)
    (:be :nbe sys.lap-x86:jbe  sys.lap-x86:cmov64be)
    (:nbe :be sys.lap-x86:jnbe sys.lap-x86:cmov64nbe)
    (:a  :na  sys.lap-x86:ja   sys.lap-x86:cmov64a)
    (:na :a   sys.lap-x86:jna  sys.lap-x86:cmov64na)
    (:s  :ns  sys.lap-x86:js   sys.lap-x86:cmov64s)
    (:ns :s   sys.lap-x86:jns  sys.lap-x86:cmov64ns)
    (:p  :np  sys.lap-x86:jp   sys.lap-x86:cmov64p)
    (:np :p   sys.lap-x86:jnp  sys.lap-x86:cmov64np)
    (:pe :po  sys.lap-x86:jpe  sys.lap-x86:cmov64pe)
    (:po :pe  sys.lap-x86:jpo  sys.lap-x86:cmov64po)
    (:l  :nl  sys.lap-x86:jl   sys.lap-x86:cmov64l)
    (:nl :l   sys.lap-x86:jnl  sys.lap-x86:cmov64nl)
    (:ge :nge sys.lap-x86:jge  sys.lap-x86:cmov64ge)
    (:nge :ge sys.lap-x86:jnge sys.lap-x86:cmov64nge)
    (:le :nle sys.lap-x86:jle  sys.lap-x86:cmov64le)
    (:nle :le sys.lap-x86:jnle sys.lap-x86:cmov64nle)
    (:g  :ng  sys.lap-x86:jg   sys.lap-x86:cmov64g)
    (:ng :g   sys.lap-x86:jng  sys.lap-x86:cmov64ng)))

(defun predicate-info (pred)
  (or (assoc pred *predicate-instructions*)
      (error "Unknown predicate ~S." pred)))

(defun invert-predicate (pred)
  (second (predicate-info pred)))

(defun load-predicate (pred)
  (smash-r8)
  (emit `(sys.lap-x86:mov64 :r8 nil)
        `(sys.lap-x86:mov64 :r9 t)
        `(,(fourth (predicate-info pred)) :r8 :r9)))

(defun predicate-result (pred)
  (cond ((eql *for-value* :predicate)
         pred)
        (t (load-predicate pred)
           (setf *r8-value* (list (gensym))))))

(defun cg-if (form)
  (let* ((else-label (gensym))
	 (end-label (gensym))
	 (test-tag (let ((*for-value* :predicate))
		     (cg-form (second form))))
	 (branch-count 0)
	 (stack-slots (set-up-for-branch))
	 (loc (when (and test-tag (not (keywordp test-tag)))
                (value-location test-tag t))))
    (when (null test-tag)
      (return-from cg-if))
    (cond ((keywordp test-tag)) ; Nothing for predicates.
          ((and (consp loc) (eq (first loc) :stack))
	   (emit `(sys.lap-x86:cmp64 (:stack ,(second loc)) nil)))
	  (t (load-in-r8 test-tag)
	     (emit `(sys.lap-x86:cmp64 :r8 nil))))
    (let ((r8-at-cond *r8-value*)
	  (stack-at-cond (make-array (length *stack-values*) :initial-contents *stack-values*)))
      ;; This is a little dangerous and relies on SET-UP-FOR-BRANCH not
      ;; changing the flags.
      (cond ((keywordp test-tag)
             ;; Invert the sense.
             (emit `(,(third (predicate-info (invert-predicate test-tag))) ,else-label)))
            (t (emit `(sys.lap-x86:je ,else-label))))
      (branch-to else-label)
      (let ((tag (cg-form (third form))))
	(when tag
	  (when *for-value*
            (case *for-value*
              (:multiple (load-multiple-values tag))
              (:predicate (if (keywordp tag)
                              (load-predicate tag)
                              (load-in-r8 tag t)))
              (t (load-in-r8 tag t))))
	  (emit `(sys.lap-x86:jmp ,end-label))
	  (incf branch-count)
	  (branch-to end-label)))
      (setf *r8-value* r8-at-cond
	    *stack-values* (copy-stack-values stack-at-cond))
      (emit-label else-label)
      (let ((tag (cg-form (fourth form))))
	(when tag
	  (when *for-value*
            (case *for-value*
              (:multiple (load-multiple-values tag))
              (:predicate (if (keywordp tag)
                              (load-predicate tag)
                              (load-in-r8 tag t)))
              (t (load-in-r8 tag t))))
	  (incf branch-count)
	  (branch-to end-label)))
      (emit-label end-label)
      (setf *stack-values* (copy-stack-values stack-slots))
      (unless (zerop branch-count)
	(setf *r8-value* (if (eql *for-value* :multiple)
                             :multiple
                             (list (gensym))))))))

(defun localp (var)
  (or (null (lexical-variable-used-in var))
      (and (null (cdr (lexical-variable-used-in var)))
	   (eq (car (lexical-variable-used-in var)) (lexical-variable-definition-point var)))))

(defconstant +binding-stack-gs-offset+ (- (* 1 8) sys.int::+tag-array-like+))
(defconstant +tls-base-offset+ (- sys.int::+tag-array-like+))
(defconstant +tls-offset-shift+ (+ 8 3))

(defun bind (sym tag)
  (push (cons sym :symbol) *special-bindings*)
  (smash-r8)
  (load-constant :r9 sym)
  (let ((has-tls-slot (gensym)))
    ;; Ensure there is a TLS slot.
    (emit `(sys.lap-x86:mov32 :eax (:symbol-flags :r9))
          `(sys.lap-x86:shr32 :eax ,+tls-offset-shift+)
          `(sys.lap-x86:and32 :eax #xFFFF)
          `(sys.lap-x86:jnz ,has-tls-slot)
          ;; Nope, allocate a new one.
          `(sys.lap-x86:mov64 :r13 (:constant sys.int::%allocate-tls-slot))
          `(sys.lap-x86:mov32 :ecx 8)
          `(sys.lap-x86:mov64 :r8 :r9)
          `(sys.lap-x86:call (:symbol-function :r13))
          `(sys.lap-x86:mov64 :lsp :rbx)
          `(sys.lap-x86:mov64 :r9 (:constant ,sym))
          `(sys.lap-x86:mov64 :rax :r8)
          `(sys.lap-x86:shr32 :eax 3)
          has-tls-slot
          ;; Save the old value on the binding stack.
          ;; See also: http://www.sbcl.org/sbcl-internals/Binding-and-unbinding.html
          ;; Bump binding stack.
          `(sys.lap-x86:gs)
          `(sys.lap-x86:sub64 (,+binding-stack-gs-offset+) 16)
          ;; Load binding stack pointer into R11.
          `(sys.lap-x86:gs)
          `(sys.lap-x86:mov64 :r11 (,+binding-stack-gs-offset+))
          ;; Read the old symbol value.
          `(sys.lap-x86:gs)
          `(sys.lap-x86:mov64 :r10 ((:rax 8) ,+tls-base-offset+))
          ;; Store the old value on the stack.
          `(sys.lap-x86:mov64 (:r11 8) :r10)
          ;; Store the symbol.
          `(sys.lap-x86:mov64 (:r11) :r9)))
  ;; Store new value.
  (load-in-r8 tag t)
  (emit `(sys.lap-x86:gs)
        `(sys.lap-x86:mov64 ((:rax 8) ,+tls-base-offset+) :r8)))

(defun unwind-to (target-reg preserve-registers)
  "Generate unwind code. TARGET-REG holds the target special stack pointer.
When PRESERVE-REGISTERS is true, all MV registers will be preserved, otherwise
only R8 will be preserved."
  (if preserve-registers
      (emit `(sys.lap-x86:mov64 (:lsp -8) nil)
            `(sys.lap-x86:mov64 (:lsp -16) nil)
            `(sys.lap-x86:mov64 (:lsp -24) nil)
            `(sys.lap-x86:mov64 (:lsp -32) nil)
            `(sys.lap-x86:mov64 (:lsp -40) nil)
            `(sys.lap-x86:mov64 (:lsp -48) nil)
            `(sys.lap-x86:mov64 (:lsp -56) nil)
            `(sys.lap-x86:sub64 :lsp 56)
            `(sys.lap-x86:mov64 (:lsp 0) :r8)
            `(sys.lap-x86:mov64 (:lsp 8) :r9)
            `(sys.lap-x86:mov64 (:lsp 16) :r10)
            `(sys.lap-x86:mov64 (:lsp 24) :r11)
            `(sys.lap-x86:mov64 (:lsp 32) :r12)
            `(sys.lap-x86:mov64 (:lsp 40) :rbx)
            `(sys.lap-x86:mov64 (:lsp 48) :rcx))
      (emit `(sys.lap-x86:mov64 (:lsp -8) nil)
            `(sys.lap-x86:sub64 :lsp 8)
            `(sys.lap-x86:mov64 (:lsp 0) :r8)))
  (let ((loop-head (gensym))
        (loop-test (gensym))
        (unwind-symbol (gensym))
        (unwind-unwind-protect (gensym))
        (unwind-bt (gensym)))
    (when (not (eql target-reg :rax))
      (emit `(sys.lap-x86:mov64 :rax ,target-reg)))
    (emit `(sys.lap-x86:jmp ,loop-test)
          loop-head)
    ;; Unwind one entry.
    (emit `(sys.lap-x86:gs)
          `(sys.lap-x86:mov64 :rcx (,+binding-stack-gs-offset+))
          `(sys.lap-x86:mov64 :r8 (:rcx))
          `(sys.lap-x86:mov8 :dl :r8l)
          `(sys.lap-x86:and8 :dl #b1111)
          `(sys.lap-x86:cmp8 :dl ,sys.int::+tag-symbol+)
          `(sys.lap-x86:je ,unwind-symbol)
          `(sys.lap-x86:cmp8 :dl ,sys.int::+tag-array-like+)
          `(sys.lap-x86:je ,unwind-bt)
          `(sys.lap-x86:cmp8 :dl ,sys.int::+tag-function+)
          `(sys.lap-x86:je ,unwind-unwind-protect)
          `(sys.lap-x86:test64 :r8 :r8)
          `(sys.lap-x86:jz ,loop-test)
          `(sys.lap-x86:ud2))
    ;; Unbinding one symbol.
    (emit unwind-symbol
          `(sys.lap-x86:mov64 :r9 (:rcx 8))
          `(sys.lap-x86:mov32 :edx (:symbol-flags :r8))
          `(sys.lap-x86:shr32 :edx ,+tls-offset-shift+)
          `(sys.lap-x86:and32 :edx #xFFFF)
          `(sys.lap-x86:gs)
          `(sys.lap-x86:mov64 ((:rdx 8) ,+tls-base-offset+) :r9)
          `(sys.lap-x86:mov64 (:rcx 0) 0)
          `(sys.lap-x86:mov64 (:rcx 8) 0)
          `(sys.lap-x86:gs)
          `(sys.lap-x86:add64 (,+binding-stack-gs-offset+) 16)
          `(sys.lap-x86:jmp ,loop-test))
    ;; Running one cleanup function.
    (emit unwind-unwind-protect
          `(sys.lap-x86:mov64 :r13 :r8)
          `(sys.lap-x86:mov64 :rbx (:rcx 8))
          `(sys.lap-x86:mov64 (:rcx 0) 0)
          `(sys.lap-x86:mov64 (:rcx 8) 0)
          `(sys.lap-x86:gs)
          `(sys.lap-x86:add64 (,+binding-stack-gs-offset+) 16)
          `(sys.lap-x86:push :rax)
          `(sys.lap-x86:push :rcx)
          `(sys.lap-x86:xor32 :ecx :ecx)
          `(sys.lap-x86:call :r13)
          `(sys.lap-x86:mov64 :lsp :rbx)
          `(sys.lap-x86:pop :rcx)
          `(sys.lap-x86:pop :rax)
          `(sys.lap-x86:jmp ,loop-test))
    ;; Invalidating one tagbody/block form.
    (emit unwind-bt
          `(sys.lap-x86:mov64 :r9 (:rcx 8))
          `(sys.lap-x86:mov64 (:r8 1 :r9) nil)
          `(sys.lap-x86:mov64 (:rcx 0) 0)
          `(sys.lap-x86:mov64 (:rcx 8) 0)
          `(sys.lap-x86:gs)
          `(sys.lap-x86:add64 (,+binding-stack-gs-offset+) 16)
          `(sys.lap-x86:jmp ,loop-test))
    (emit loop-test
          `(sys.lap-x86:gs)
          `(sys.lap-x86:cmp64 :rax (,+binding-stack-gs-offset+))
          `(sys.lap-x86:ja ,loop-head)))
  (if preserve-registers
      ;; Restore MV-registers.
      (emit `(sys.lap-x86:mov64 :r8 (:lsp 0))
            `(sys.lap-x86:mov64 :r9 (:lsp 8))
            `(sys.lap-x86:mov64 :r10 (:lsp 16))
            `(sys.lap-x86:mov64 :r11 (:lsp 24))
            `(sys.lap-x86:mov64 :r12 (:lsp 32))
            `(sys.lap-x86:mov64 :rbx (:lsp 40))
            `(sys.lap-x86:mov64 :rcx (:lsp 48))
            `(sys.lap-x86:add64 :lsp 56))
      (emit `(sys.lap-x86:mov64 :r8 (:lsp 0))
            `(sys.lap-x86:add64 :lsp 8))))

(defun unbind-to (bindings target)
  (unless (eql bindings target)
    (when (eql *for-value* :predicate)
      (error "Cannot unbind in predicate mode."))
    (let ((b (first bindings)))
      (ecase (cdr b)
        (:unwind-protect ;; Unwind-protect cleanup function.
         (case *for-value*
           (:multiple
            ;; Save all MV-related registers on the stacks.
            (emit `(sys.lap-x86:mov64 (:lsp -8) nil)
                  `(sys.lap-x86:mov64 (:lsp -16) nil)
                  `(sys.lap-x86:mov64 (:lsp -24) nil)
                  `(sys.lap-x86:mov64 (:lsp -32) nil)
                  `(sys.lap-x86:mov64 (:lsp -40) nil)
                  `(sys.lap-x86:mov64 (:lsp -48) nil)
                  `(sys.lap-x86:mov64 (:lsp -56) nil)
                  `(sys.lap-x86:sub64 :lsp 56)
                  `(sys.lap-x86:mov64 (:lsp 0) :r8)
                  `(sys.lap-x86:mov64 (:lsp 8) :r9)
                  `(sys.lap-x86:mov64 (:lsp 16) :r10)
                  `(sys.lap-x86:mov64 (:lsp 24) :r11)
                  `(sys.lap-x86:mov64 (:lsp 32) :r12)
                  `(sys.lap-x86:mov64 (:lsp 40) :rbx)
                  `(sys.lap-x86:mov64 (:lsp 48) :rcx))
            ;; Call function.
            (load-in-reg :r13 (car b))
            (emit `(sys.lap-x86:xor32 :ecx :ecx)
                  `(sys.lap-x86:call :r13)
                  `(sys.lap-x86:mov64 :lsp :rbx))
            ;; Drop from special stack.
            (emit `(sys.lap-x86:gs)
                  `(sys.lap-x86:mov64 :r8 (,+binding-stack-gs-offset+))
                  `(sys.lap-x86:mov64 (:r8) 0)
                  `(sys.lap-x86:mov64 (:r8 8) 0)
                  `(sys.lap-x86:gs)
                  `(sys.lap-x86:add64 (,+binding-stack-gs-offset+) 16))
            ;; Restore MV-registers.
            (emit `(sys.lap-x86:mov64 :r8 (:lsp 0))
                  `(sys.lap-x86:mov64 :r9 (:lsp 8))
                  `(sys.lap-x86:mov64 :r10 (:lsp 16))
                  `(sys.lap-x86:mov64 :r11 (:lsp 24))
                  `(sys.lap-x86:mov64 :r12 (:lsp 32))
                  `(sys.lap-x86:mov64 :rbx (:lsp 40))
                  `(sys.lap-x86:mov64 :rcx (:lsp 48))
                  `(sys.lap-x86:add64 :lsp 56)))
           (t (smash-r8)
              (load-in-reg :r13 (car b))
              (emit `(sys.lap-x86:xor32 :ecx :ecx)
                    `(sys.lap-x86:call :r13)
                    `(sys.lap-x86:mov64 :lsp :rbx)
                    `(sys.lap-x86:gs)
                    `(sys.lap-x86:mov64 :r8 (,+binding-stack-gs-offset+))
                    `(sys.lap-x86:mov64 (:r8) 0)
                    `(sys.lap-x86:mov64 (:r8 8) 0)
                    `(sys.lap-x86:gs)
                    `(sys.lap-x86:add64 (,+binding-stack-gs-offset+) 16)))))
        (:tagbody-or-block
         ;; Null out the given slot.
         (emit `(sys.lap-x86:mov64 :r13 (:stack ,(first (first b))))
               `(sys.lap-x86:mov64 (:r13 ,(1+ (* (second (first b)) 8))) nil)
               `(sys.lap-x86:gs)
               `(sys.lap-x86:mov64 :rax (,+binding-stack-gs-offset+))
               `(sys.lap-x86:mov64 (:rax) 0)
               `(sys.lap-x86:mov64 (:rax 8) 0)
               `(sys.lap-x86:gs)
               `(sys.lap-x86:add64 (,+binding-stack-gs-offset+) 16)))
        (:symbol ;; Special variable
         (case *for-value*
           (:multiple
            ;; Stash R8 and R9 on the stack.
            (emit `(sys.lap-x86:mov64 (:lsp -8) nil)
                  `(sys.lap-x86:mov64 (:lsp -16) nil)
                  `(sys.lap-x86:sub64 :lsp 16)
                  `(sys.lap-x86:mov64 (:lsp 0) :r8)
                  `(sys.lap-x86:mov64 (:lsp 8) :r9))
            ;; Unbind.
            (load-constant :r9 (car b))
            (emit `(sys.lap-x86:gs)
                  `(sys.lap-x86:mov64 :rax (,+binding-stack-gs-offset+))
                  `(sys.lap-x86:mov64 :r8 (:rax 8))
                  `(sys.lap-x86:mov32 :edx (:symbol-flags :r9))
                  `(sys.lap-x86:shr32 :edx ,+tls-offset-shift+)
                  `(sys.lap-x86:and32 :edx #xFFFF)
                  `(sys.lap-x86:gs)
                  `(sys.lap-x86:mov64 ((:rdx 8) ,+tls-base-offset+) :r8)
                  `(sys.lap-x86:mov64 (:rax) 0)
                  `(sys.lap-x86:mov64 (:rax 8) 0)
                  `(sys.lap-x86:gs)
                  `(sys.lap-x86:add64 (,+binding-stack-gs-offset+) 16))
            ;; Restore registers.
            (emit `(sys.lap-x86:mov64 :r8 (:lsp 0))
                  `(sys.lap-x86:mov64 :r9 (:lsp 8))
                  `(sys.lap-x86:add64 :lsp 16)))
           (t (load-constant :r9 (car b))
              (emit `(sys.lap-x86:gs)
                    `(sys.lap-x86:mov64 :rax (,+binding-stack-gs-offset+))
                    `(sys.lap-x86:mov64 :r10 (:rax 8))
                    `(sys.lap-x86:mov32 :edx (:symbol-flags :r9))
                    `(sys.lap-x86:shr32 :edx ,+tls-offset-shift+)
                    `(sys.lap-x86:and32 :edx #xFFFF)
                    `(sys.lap-x86:gs)
                    `(sys.lap-x86:mov64 ((:rdx 8) ,+tls-base-offset+) :r10)
                    `(sys.lap-x86:mov64 (:rax) 0)
                    `(sys.lap-x86:mov64 (:rax 8) 0)
                    `(sys.lap-x86:gs)
                    `(sys.lap-x86:add64 (,+binding-stack-gs-offset+) 16)))))))
    (unbind-to (rest bindings) target)))

(defun cg-let (form)
  (let* ((bindings (second form))
         (variables (mapcar 'first bindings))
         (body (cddr form))
         (unbind-point *special-bindings*)
         (*special-bindings* *special-bindings*)
         (specials '()))
    (let ((env-size (count-if (lambda (x) (and (lexical-variable-p x) (not (localp x)))) variables))
          (*environment* *environment*)
          (*environment-chain* *environment-chain*))
      (unless (zerop env-size)
        (push (remove-if (lambda (x) (or (symbolp x) (localp x))) variables) *environment*)
        (smash-r8)
        ;; Allocate an environment frame.
        ;; TODO: Escape analysis for dynamic extent.
        (emit `(sys.lap-x86:mov64 :r13 (:constant sys.int::make-simple-vector))
              `(sys.lap-x86:mov32 :ecx 8)
              `(sys.lap-x86:mov32 :r8d ,(* (1+ env-size) 8))
              `(sys.lap-x86:call (:symbol-function :r13))
              `(sys.lap-x86:mov64 :lsp :rbx)
              `(sys.lap-x86:mov64 :rbx :r8))
        (when *environment-chain*
          ;; Set back-link.
          (emit `(sys.lap-x86:mov64 :r8 (:stack ,(first *environment-chain*)))
                `(sys.lap-x86:mov64 (:rbx 1) :r8)))
        (let ((slot (find-stack-slot)))
          (setf (aref *stack-values* slot) (cons :environment :home))
          (push slot *environment-chain*)
          (emit `(sys.lap-x86:mov64 (:stack ,slot) :rbx))))
      (dolist (b (second form))
        (let* ((var (first b))
               (init-form (second b)))
          (cond ((symbolp var)
                 (let* ((*for-value* t)
                        (tag (cg-form init-form)))
                   (push (list var tag) specials)))
                ((zerop (lexical-variable-use-count var))
                 (let ((*for-value* nil))
                   (cg-form init-form)))
                ((localp var)
                 (let ((slot (find-stack-slot)))
                   (setf (aref *stack-values* slot) (cons var :home))
                   (let* ((*for-value* t)
                          (tag (cg-form init-form)))
                     (load-in-r8 tag t)
                     (setf *r8-value* (cons var :dup))
                         (emit `(sys.lap-x86:mov64 (:stack ,slot) :r8)))))
                (t (let* ((env-slot (position var (first *environment*)))
                          (*for-value* t)
                          (tag (cg-form init-form)))
                     (load-in-r8 tag t)
                     (emit `(sys.lap-x86:mov64 :rbx (:stack ,(first *environment-chain*)))
                           `(sys.lap-x86:mov64 (:rbx ,(+ 1 (* (1+ env-slot) 8)))
                                               :r8)))))))
      ;; Perform special binding.
      (mapc (lambda (var)
              (bind (first var) (second var)))
            specials)
      ;; Unbind cannot save predicate results.
      (let ((*for-value* (if (eql *for-value* :predicate)
                             t
                             *for-value*)))
        (prog1 (cg-form `(progn ,@body))
          (unbind-to *special-bindings* unbind-point))))))

;;;(defun cg-load-time-value (form))

(defun cg-multiple-value-bind (form)
  (let ((variables (second form))
        (value-form (third form))
        (body (cdddr form)))
    (when (some 'symbolp variables)
      (return-from cg-multiple-value-bind (cg-form `(error '"TODO: special variable binding (m-v-bind)"))))
    (let ((env-size (count-if (lambda (x) (and (lexical-variable-p x) (not (localp x)))) variables))
          (*environment* *environment*)
          (*environment-chain* *environment-chain*))
      (unless (zerop env-size)
        (push (remove-if 'localp variables) *environment*)
        (smash-r8)
        ;; Allocate an environment frame.
        ;; TODO: Escape analysis for dynamic extent.
        (emit `(sys.lap-x86:mov64 :r13 (:constant sys.int::make-simple-vector))
              `(sys.lap-x86:mov32 :ecx 8)
              `(sys.lap-x86:mov32 :r8d ,(* (1+ env-size) 8))
              `(sys.lap-x86:call (:symbol-function :r13))
              `(sys.lap-x86:mov64 :lsp :rbx)
              `(sys.lap-x86:mov64 :rbx :r8))
        (when *environment-chain*
          ;; Set back-link.
          (emit `(sys.lap-x86:mov64 :r8 (:stack ,(first *environment-chain*)))
                `(sys.lap-x86:mov64 (:rbx 1) :r8)))
        (let ((slot (find-stack-slot)))
          (setf (aref *stack-values* slot) (cons :environment :home))
          (push slot *environment-chain*)
          (emit `(sys.lap-x86:mov64 (:stack ,slot) :rbx))))
      ;; Initialize local variables to NIL.
      (dolist (var variables)
        (cond ((zerop (lexical-variable-use-count var)))
              ((localp var)
               (let ((slot (find-stack-slot)))
                 (setf (aref *stack-values* slot) (cons var :home))
                 (emit `(sys.lap-x86:mov64 (:stack ,slot) nil))))
              (t)))
      ;; Compile the value-form.
      (let ((value-tag (let ((*for-value* :multiple))
                         (cg-form value-form))))
        (load-multiple-values value-tag))
      ;; Bind variables.
      (let* ((jump-targets (mapcar (lambda (x)
                                     (declare (ignore x))
                                     (gensym))
                                   variables))
             (no-vals-label (gensym))
             (var-count (length variables))
             (value-locations (nreverse (subseq '(:r8 :r9 :r10 :r11 :r12) 0 (min 5 var-count)))))
        (dotimes (i (- var-count 5))
          (push i value-locations))
        (emit `(sys.lap-x86:mov64 :rax :rbx))
        (dotimes (i var-count)
          (emit `(sys.lap-x86:cmp64 :rcx ,(fixnum-to-raw (- var-count i)))
                `(sys.lap-x86:jae ,(nth i jump-targets))))
        (emit `(sys.lap-x86:jmp ,no-vals-label))
        (mapc (lambda (var label)
                (emit label)
                (cond ((zerop (lexical-variable-use-count var))
                       (pop value-locations))
                      (t (let ((register (cond ((integerp (first value-locations))
                                                (emit `(sys.lap-x86:mov64 :rbx (:lsp ,(* (pop value-locations) 8))))
                                                :rbx)
                                               (t (pop value-locations)))))
                           (cond ((localp var)
                                  (emit `(sys.lap-x86:mov64 (:stack ,(position (cons var :home)
                                                                               *stack-values*
                                                                               :test 'equal))
                                                            ,register)))
                                 (t (multiple-value-bind (stack-slot depth offset)
                                        (find-var var *environment* *environment-chain*)
                                      (unless (zerop depth)
                                        (return-from cg-multiple-value-bind (cg-form '(error '"TODO: deep non-local lexical variables."))))
                                      (emit `(sys.lap-x86:mov64 :r13 (:stack ,stack-slot))
                                            `(sys.lap-x86:mov64 (:r13 ,(1+ (* (1+ offset) 8))) ,register))
                                      (setf *r8-value* (list (gensym))))))))))
              (reverse variables)
              jump-targets)
        (emit no-vals-label
              `(sys.lap-x86:mov64 :lsp :rax)))
      (cg-form `(progn ,@body)))))

(defun cg-multiple-value-call (form)
  (let ((function (second form))
        (value-forms (cddr form)))
    (cond ((null value-forms)
           ;; Just like a regular call.
           (cg-function-form `(funcall ,function)))
          ((null (cdr value-forms))
           ;; Single value form.
           (let ((fn-tag (let ((*for-value* t)) (cg-form function)))
                 (stack-pointer-save-area (allocate-control-stack-slots 1)))
             (when (not fn-tag)
               (return-from cg-multiple-value-call nil))
             (let ((value-tag (let ((*for-value* :multiple))
                                (cg-form (first value-forms)))))
               (when (not value-tag)
                 (return-from cg-multiple-value-call nil))
               (load-multiple-values value-tag)
               (emit `(sys.lap-x86:mov64 ,(control-stack-slot-ea stack-pointer-save-area) :rbx))
               (smash-r8)
               (load-in-reg :r13 fn-tag t)
               (let ((type-error-label (gensym))
                     (function-label (gensym)))
                 (emit-trailer (type-error-label)
                   (raise-type-error :r13 '(or function symbol)))
                 (emit `(sys.lap-x86:mov8 :al :r13l)
                       `(sys.lap-x86:and8 :al #b1111)
                       `(sys.lap-x86:cmp8 :al ,sys.int::+tag-function+)
                       `(sys.lap-x86:je ,function-label)
                       `(sys.lap-x86:cmp8 :al ,sys.int::+tag-symbol+)
                       `(sys.lap-x86:jne ,type-error-label)
                       `(sys.lap-x86:mov64 :r13 (:symbol-function :r13))
                       function-label
                       `(sys.lap-x86:call :r13))
                 (cond ((eql *for-value* :multiple)
                        (emit `(sys.lap-x86:mov64 :rbx ,(control-stack-slot-ea stack-pointer-save-area)))
                        :multiple)
                       (t (emit `(sys.lap-x86:mov64 :lsp ,(control-stack-slot-ea stack-pointer-save-area)))
                          (setf *r8-value* (list (gensym)))))))))
          (t (cg-function-form `(error '"TODO multiple-value-call with >1 arguments."))))))

(defun cg-multiple-value-prog1 (form)
  (cond
    ((null *for-value*)
     ;; Not for value
     (cg-progn form))
    (t (let ((tag (let ((*for-value* (if (eql *for-value* :predicate)
                                         t
                                         *for-value*)))
                    (cg-form (second form)))))
         (smash-r8)
         (when (eql tag :multiple)
           ;; Save MV registers.
           (emit `(sys.lap-x86:mov64 (:lsp -8) nil)
                 `(sys.lap-x86:mov64 (:lsp -16) nil)
                 `(sys.lap-x86:mov64 (:lsp -24) nil)
                 `(sys.lap-x86:mov64 (:lsp -32) nil)
                 `(sys.lap-x86:mov64 (:lsp -40) nil)
                 `(sys.lap-x86:mov64 (:lsp -48) nil)
                 `(sys.lap-x86:mov64 (:lsp -56) nil)
                 `(sys.lap-x86:sub64 :lsp 56)
                 `(sys.lap-x86:mov64 (:lsp 0) :r8)
                 `(sys.lap-x86:mov64 (:lsp 8) :r9)
                 `(sys.lap-x86:mov64 (:lsp 16) :r10)
                 `(sys.lap-x86:mov64 (:lsp 24) :r11)
                 `(sys.lap-x86:mov64 (:lsp 32) :r12)
                 `(sys.lap-x86:mov64 (:lsp 40) :rbx)
                 `(sys.lap-x86:mov64 (:lsp 48) :rcx)))
         (let ((*for-value* nil))
           (when (not (cg-progn `(progn ,@(cddr form))))
             ;; No return.
             (setf *load-list* (delete tag *load-list*))
             (return-from cg-multiple-value-prog1 'nil)))
         (smash-r8)
         ;; Drop the tag from the load-list to prevent duplicates caused by cg-form
         (setf *load-list* (delete tag *load-list*))
         (when (eql tag :multiple)
           ;; Restore MV registers.
           (emit `(sys.lap-x86:mov64 :r8 (:lsp 0))
                 `(sys.lap-x86:mov64 :r9 (:lsp 8))
                 `(sys.lap-x86:mov64 :r10 (:lsp 16))
                 `(sys.lap-x86:mov64 :r11 (:lsp 24))
                 `(sys.lap-x86:mov64 :r12 (:lsp 32))
                 `(sys.lap-x86:mov64 :rbx (:lsp 40))
                 `(sys.lap-x86:mov64 :rcx (:lsp 48))
                 `(sys.lap-x86:add64 :lsp 56)))
         tag))))

(defun cg-progn (form)
  (if (rest form)
      (do ((i (rest form) (rest i)))
	  ((endp (rest i))
	   (cg-form (first i)))
	(let* ((*for-value* nil)
	       (tag (cg-form (first i))))
	  (when (null tag)
	    (return-from cg-progn 'nil))))
      (cg-form ''nil)))

(defun cg-progv (form)
  (cg-form `(error '"Cannot codegen progv yet.")))

(defun cg-quote (form)
  form)

(defun cg-return-from (form)
  (let* ((local-info (assoc (second form) *rename-list*))
         (*for-value* (block-information-return-mode (second form)))
         (tag (cg-form (third form))))
    (cond ((eql *for-value* :multiple)
           (load-multiple-values tag))
          (*for-value*
           (load-in-r8 tag t)))
    (incf (block-information-count (second form)))
    (smash-r8)
    (cond (local-info ;; Local jump.
           (unbind-to *special-bindings* (third local-info))
           (emit `(sys.lap-x86:jmp ,(second local-info))))
          (t ;; Non-local exit, unwind required.
           (let ((invalid-block (gensym)))
             (emit-trailer (invalid-block)
               (load-constant :r8 (block-information-name (second form)))
               (load-constant :r13 'sys.int::raise-bad-block)
               (emit `(sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 1))
                     `(sys.lap-x86:call (:symbol-function :r13))
                     `(sys.lap-x86:ud2)))
             (multiple-value-bind (stack-slot depth offset)
                 (find-var (second form) *environment* *environment-chain*)
               (when *for-value*
                 ;; Save R8 (first value).
                 (emit `(sys.lap-x86:mov64 (:lsp -8) nil)
                       `(sys.lap-x86:sub64 :lsp 8)
                       `(sys.lap-x86:mov64 (:lsp 0) :r8)))
               (emit `(sys.lap-x86:mov64 :r8 (:stack ,stack-slot)))
               (dotimes (n depth)
                 (emit `(sys.lap-x86:mov64 :r8 (:r8 1))))
               (emit `(sys.lap-x86:mov64 :r8 (:r8 ,(1+ (* (1+ offset) 8)))))
               ;; R8 holds the block info, ensure it's still valid.
               (emit `(sys.lap-x86:cmp64 :r8 nil)
                     `(sys.lap-x86:je ,invalid-block)
                     `(sys.lap-x86:mov64 :rax (:r8 8)))
               (unwind-to :rax *for-value*)
               ;; Block info is just a fixnum, so can go in an arbitrary register.
               (emit `(sys.lap-x86:mov64 :rax :r8))
               ;; Restore first value.
               (when *for-value*
                 (emit `(sys.lap-x86:mov64 :r8 (:lsp 0))
                       `(sys.lap-x86:add64 :lsp 8)))
               ;; Restore registers.
               (emit `(sys.lap-x86:mov64 :csp (:rax 16))
                     `(sys.lap-x86:mov64 :cfp (:rax 24))
                     `(sys.lap-x86:mov64 :lsp (:rax 32))
                     `(sys.lap-x86:mov64 :lfp (:rax 40))
                     ;; GO GO GO!
                     `(sys.lap-x86:jmp (:rax 0)))))))
    'nil))

(defun find-variable-home (var)
  (dotimes (i (length *stack-values*)
	    (error "No home for ~S?" var))
    (let ((x (aref *stack-values* i)))
      (when (and (consp x) (eq (car x) var) (eq (cdr x) :home))
	(return i)))))

(defun cg-setq (form)
  (let ((var (second form))
	(val (third form)))
    (cond ((localp var)
           ;; Copy var if there are unsatisfied tags on the load list.
           (dolist (l *load-list*)
             (when (and (consp l) (eq (car l) var))
               ;; Don't save if there is something satisfying this already.
               (multiple-value-bind (loc true-tag)
                   (value-location l)
                 (declare (ignore loc))
                 (unless (tag-saved-on-stack-p true-tag)
                   (load-in-r8 l nil)
                   (smash-r8 t)))))
           (let ((tag (let ((*for-value* t)) (cg-form val)))
                 (home (find-variable-home var)))
             (when (null tag)
               (return-from cg-setq))
             (load-in-r8 tag t)
             (emit `(sys.lap-x86:mov64 (:stack ,home) :r8))
             (setf *r8-value* (cons var :dup))
             (cons var (incf *run-counter* 2))))
          (t (let ((tag (let ((*for-value* t)) (cg-form val))))
               (when (null tag)
                 (return-from cg-setq))
               (multiple-value-bind (stack-slot depth offset)
                   (find-var var *environment* *environment-chain*)
                 (load-in-r8 tag t)
                 (emit `(sys.lap-x86:mov64 :r9 (:stack ,stack-slot)))
                 (dotimes (n depth)
                   (emit `(sys.lap-x86:mov64 :r9 (:r9 1))))
                 (emit `(sys.lap-x86:mov64 (:r9 ,(1+ (* (1+ offset) 8))) :r8))
                 (setf *r8-value* (list (gensym)))))))))

(defun tagbody-localp (info)
  (dolist (tag (tagbody-information-go-tags info) t)
    (unless (or (null (go-tag-used-in tag))
		(and (null (cdr (go-tag-used-in tag)))
		     (eq (car (go-tag-used-in tag)) (tagbody-information-definition-point info))))
      (return nil))))

;;; FIXME: Everything must return a valid tag if control flow follows.

(defun cg-tagbody (form)
  (let ((*for-value* nil)
	(stack-slots nil)
	(*rename-list* *rename-list*)
	(last-value t)
        (escapes (not (tagbody-localp (second form))))
        (jump-table (gensym))
        (*environment* *environment*)
        (*environment-chain* *environment-chain*)
        (*special-bindings* *special-bindings*)
        (tag-labels (mapcar (lambda (tag)
                              (declare (ignore tag))
                              (gensym))
                            (tagbody-information-go-tags (second form)))))
    (when escapes
      ;; Emit the jump-table.
      ;; TODO: Prune local labels out.
      (emit-trailer (jump-table)
        (dolist (i tag-labels)
          (emit `(:d64/le (- ,i ,jump-table)))))
      (smash-r8)
      ;; Allocate an environment for the tagbody.
      (emit `(sys.lap-x86:mov64 :r13 (:constant sys.int::make-simple-vector))
            `(sys.lap-x86:mov32 :ecx 8)
            `(sys.lap-x86:mov32 :r8d ,(* 2 8)) ; Backlink & pointer.
            `(sys.lap-x86:call (:symbol-function :r13))
            `(sys.lap-x86:mov64 :lsp :rbx))
      (when *environment-chain*
        ;; Set back-link.
        (emit `(sys.lap-x86:mov64 :r9 (:stack ,(first *environment-chain*)))
              `(sys.lap-x86:mov64 (:r8 1) :r9)))
      (let ((slot (find-stack-slot))
            (control-info (allocate-control-stack-slots 6)))
        ;; Construct jump info.
        (emit `(sys.lap-x86:lea64 :rax (:rip ,jump-table))
              `(sys.lap-x86:mov64 ,(control-stack-slot-ea control-info) :rax)
              `(sys.lap-x86:gs)
              `(sys.lap-x86:mov64 :rax (,+binding-stack-gs-offset+))
              ;; Ensure that the info does not get invalidated by a GO to
              ;; this tagbody.
              `(sys.lap-x86:sub64 :rax 16)
              `(sys.lap-x86:mov64 ,(control-stack-slot-ea (- control-info 1)) :rax)
              `(sys.lap-x86:mov64 ,(control-stack-slot-ea (- control-info 2)) :csp)
              `(sys.lap-x86:mov64 ,(control-stack-slot-ea (- control-info 3)) :cfp)
              `(sys.lap-x86:mov64 ,(control-stack-slot-ea (- control-info 4)) :lsp)
              `(sys.lap-x86:mov64 ,(control-stack-slot-ea (- control-info 5)) :lfp)
              ;; Save in the environment.
              `(sys.lap-x86:lea64 :rax ,(control-stack-slot-ea control-info))
              `(sys.lap-x86:mov64 (:r8 9) :rax))
        (setf (aref *stack-values* slot) (cons :environment :home))
        (push slot *environment-chain*)
        (emit `(sys.lap-x86:mov64 (:stack ,slot) :r8))
        (push (list (second form)) *environment*)
        (push (cons (list slot 2) :tagbody-or-block) *special-bindings*)
        (emit `(sys.lap-x86:gs)
              `(sys.lap-x86:sub64 (,+binding-stack-gs-offset+) 16)
              `(sys.lap-x86:gs)
              `(sys.lap-x86:mov64 :rax (,+binding-stack-gs-offset+))
              `(sys.lap-x86:mov64 (:rax 8) 8)
              `(sys.lap-x86:mov64 (:rax 0) :r8))))
    (setf stack-slots (set-up-for-branch))
    (mapcar (lambda (tag label)
              (push (list tag label *special-bindings*) *rename-list*))
            (tagbody-information-go-tags (second form)) tag-labels)
    (dolist (stmt (cddr form))
      (if (go-tag-p stmt)
	  (progn
	    (smash-r8)
	    (setf *stack-values* (copy-stack-values stack-slots))
	    (setf last-value t)
	    (emit (second (assoc stmt *rename-list*))))
	  (setf last-value (cg-form stmt))))
    (when escapes
      ;; Disable the tagbody and pops the binding stack.
      (emit `(sys.lap-x86:mov64 :r9 (:stack ,(first *environment-chain*)))
            `(sys.lap-x86:mov64 (:r9 9) nil)
            `(sys.lap-x86:gs)
            `(sys.lap-x86:mov64 :rax (,+binding-stack-gs-offset+))
            `(sys.lap-x86:mov64 (:rax 0) 0)
            `(sys.lap-x86:mov64 (:rax 8) 0)
            `(sys.lap-x86:gs)
            `(sys.lap-x86:add64 (,+binding-stack-gs-offset+) 16)))
    (if last-value
	''nil
	'nil)))

(defun cg-the (form)
  (cg-form (third form)))

(defun cg-unwind-protect (form)
  ;; Compile the cleanup function and push on the binding stack.
  (let* ((cleanup-tag (let ((*for-value* t))
                        (cg-form (third form))))
         (*special-bindings* (cons (cons cleanup-tag :unwind-protect) *special-bindings*)))
    (load-in-r8 cleanup-tag)
    (emit `(sys.lap-x86:gs)
          `(sys.lap-x86:sub64 (,+binding-stack-gs-offset+) 16)
          `(sys.lap-x86:gs)
          `(sys.lap-x86:mov64 :rax (,+binding-stack-gs-offset+))
          `(sys.lap-x86:mov64 (:rax 0) :r8))
    ;; Compile the protected form (not for predicate).
    (let ((tag (let ((*for-value* (if (and (keywordp *for-value*)
                                           (not (eql *for-value* :multiple)))
                                      t
                                      *for-value*)))
                 (cg-form (second form)))))
      (when tag
        (cond ((eql *for-value* :multiple)
               (load-multiple-values tag))
              (*for-value*
               (load-in-r8 tag t)))
        (unbind-to *special-bindings* (rest *special-bindings*))
        ;; Kill cleanup-tag, not needed past here.
        (setf *load-list* (delete cleanup-tag *load-list*))
        tag))))

(defun fixnump (object)
  (typep object '(signed-byte 61)))

(defun value-location (tag &optional kill)
  (when kill
    (setf *load-list* (delete tag *load-list*)))
  (cond ((eq (car tag) 'quote)
	 (values (if (and (consp *r8-value*)
			  (eq (car *r8-value*) 'quote)
			  (eql (cadr tag) (cadr *r8-value*)))
		     :r8
		     tag)
		 tag))
	((null (cdr tag))
	 (values (if (eq tag *r8-value*)
		     :r8
		     (dotimes (i (length *stack-values*)
			       (error "Cannot find tag ~S." tag))
		       (when (eq tag (aref *stack-values* i))
			 (return (list :stack i)))))
		 tag))
	((lexical-variable-p (car tag))
	 ;; Search for the lowest numbered time that is >= to the tag time.
	 (let ((best (when (and (consp *r8-value*) (eq (car *r8-value*) (car tag))
				(integerp (cdr *r8-value*)) (>= (cdr *r8-value*) (cdr tag)))
		       *r8-value*))
	       (best-loc :r8)
	       (home-loc nil)
	       (home nil))
	   (dotimes (i (length *stack-values*))
	     (let ((val (aref *stack-values* i)))
	       (when (and (consp val) (eq (car val) (car tag)))
		 (cond ((eq (cdr val) :home)
			(setf home (cons (car val) *run-counter*)
			      home-loc (list :stack i)))
		       ((and (integerp (cdr val)) (>= (cdr val) (cdr tag))
			     (or (null best)
				 (< (cdr val) (cdr best))))
			(setf best val
			      best-loc (list :stack i)))))))
	   (values (or (when best
			 best-loc)
		       ;; R8 might hold a duplicate (thanks to let or setq), use that instead of home.
		       (when (and *r8-value* (consp *r8-value*) (eq (car *r8-value*) (car tag)) (eq (cdr *r8-value*) :dup))
			 :r8)
		       home-loc
		       (error "Cannot find tag ~S." tag))
		   (or best
		       (when (and *r8-value* (consp *r8-value*) (eq (car *r8-value*) (car tag)) (eq (cdr *r8-value*) :dup))
			 *r8-value*)
		       home))))
	(t (error "What kind of tag is this? ~S" tag))))

(defun condemed-p (tag)
  (cond ((eq (cdr tag) :home)
	 nil)
	((eq (cdr tag) :dup)
	 t)
	(t (dolist (v *load-list* t)
	     (when (eq (first tag) (first v))
	       (if (null (rest tag))
		   (return nil)
		   ;; Figure out the best tag that satisfies this load.
		   (let ((best (when (and (consp *r8-value*) (eq (car *r8-value*) (car tag))
					  (integerp (cdr *r8-value*)) (>= (cdr *r8-value*) (cdr tag)))
				 *r8-value*)))
		     (dotimes (i (length *stack-values*))
		       (let ((val (aref *stack-values* i)))
			 (when (and (consp val) (eq (car val) (car v))
				    (integerp (cdr val)) (>= (cdr val) (cdr v))
				    (or (null best)
					(< (cdr val) (cdr best))))
			   (setf best val))))
		     (when (eq best tag)
		       (return nil)))))))))

(defun find-stack-slot ()
  ;; Find a free stack slot, or allocate a new one.
  (dotimes (i (length *stack-values*)
	    (vector-push-extend nil *stack-values*))
    (when (or (null (aref *stack-values* i))
	      (condemed-p (aref *stack-values* i)))
      (setf (aref *stack-values* i) nil)
      (return i))))

(defun smash-r8 (&optional do-not-kill-r8)
  "Check if the value in R8 is on the load-list and flush it to the stack if it is."
  ;; Avoid flushing if it's already on the stack.
  (when (and *r8-value*
             (not (eql *r8-value* :multiple))
	     (not (condemed-p *r8-value*))
	     (not (tag-saved-on-stack-p *r8-value*)))
    (let ((slot (find-stack-slot)))
      (setf (aref *stack-values* slot) *r8-value*)
      (emit `(sys.lap-x86:mov64 (:stack ,slot) :r8))))
  (unless do-not-kill-r8
    (setf *r8-value* nil)))

(defun load-constant (register value)
  (cond ((eql value 0)
	 (emit `(sys.lap-x86:xor64 ,register ,register)))
	((eq value 'nil)
	 (emit `(sys.lap-x86:mov64 ,register nil)))
	((eq value 't)
	 (emit `(sys.lap-x86:mov64 ,register t)))
	((fixnump value)
	 (emit `(sys.lap-x86:mov64 ,register ,(fixnum-to-raw value))))
	((characterp value)
	 (emit `(sys.lap-x86:mov64 ,register ,(character-to-raw value))))
	(t (emit `(sys.lap-x86:mov64 ,register (:constant ,value))))))

(defun load-multiple-values (tag)
  (cond ((eql tag :multiple))
        (t (load-in-r8 tag t)
           (emit `(sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 1))
                 `(sys.lap-x86:mov64 :rbx :lsp)))))

(defun load-in-r8 (tag &optional kill)
  (multiple-value-bind (loc true-tag)
      (value-location tag nil)
    (unless (eq loc :r8)
      (smash-r8)
      (ecase (first loc)
	((quote) (load-constant :r8 (second loc)))
	((:stack) (emit `(sys.lap-x86:mov64 :r8 (:stack ,(second loc))))))
      (setf *r8-value* true-tag))
    (when kill
      (setf *load-list* (delete tag *load-list*)))))

(defun load-in-reg (reg tag &optional kill)
  (if (eql reg :r8)
      (load-in-r8 tag kill)
      (let ((loc (value-location tag nil)))
	(unless (eql loc reg)
	  (if (eql loc :r8)
	      (emit `(sys.lap-x86:mov64 ,reg :r8))
	      (ecase (first loc)
		((quote) (load-constant reg (second loc)))
		((:stack) (emit `(sys.lap-x86:mov64 ,reg (:stack ,(second loc))))))))
	(when kill
	  (setf *load-list* (delete tag *load-list*))))))

(defun prep-arguments-for-call (arg-forms)
  (when arg-forms
    (let ((args '())
	  (arg-count 0))
      (let ((*for-value* t))
	(dolist (f arg-forms)
	  (push (cg-form f) args)
	  (incf arg-count)
	  (when (null (first args))
	    ;; Non-local control transfer, don't actually need those results now.
	    (dolist (i (rest args))
	      (setf *load-list* (delete i *load-list*)))
	    (return-from prep-arguments-for-call nil))))
      (setf args (nreverse args))
      ;; Interrupts are not a problem here.
      ;; They switch stack groups and don't touch the Lisp stack.
      (let ((stack-count (- arg-count 5)))
	(when (plusp stack-count)
	  ;; Clear the new stack slots.
	  (dotimes (i stack-count)
	    (emit `(sys.lap-x86:mov64 (:lsp ,(- (* (1+ i) 8))) nil)))
	  ;; Adjust the stack.
	  (emit `(sys.lap-x86:sub64 :lsp ,(* stack-count 8)))
	  ;; Load values on the stack.
	  ;; Use r13 here to preserve whatever is in r8.
	  (do ((i 0 (1+ i))
	       (j (nthcdr 5 args) (cdr j)))
	      ((null j))
	    (load-in-reg :r13 (car j) t)
	    (emit `(sys.lap-x86:mov64 (:lsp ,(* i 8)) :r13)))))
      ;; Load other values in registers.
      (when (> arg-count 4)
	(load-in-reg :r12 (nth 4 args) t))
      (when (> arg-count 3)
	(load-in-reg :r11 (nth 3 args) t))
      (when (> arg-count 2)
	(load-in-reg :r10 (nth 2 args) t))
      (when (> arg-count 1)
	(load-in-reg :r9 (nth 1 args) t))
      (when (> arg-count 0)
	(load-in-r8 (nth 0 args) t))))
  t)

;; Compile a VALUES form.
(defun cg-values (forms)
  (cond ((null forms)
         ;; No values.
         (cond ((eql *for-value* :multiple)
                ;; R8 must hold NIL.
                (load-in-r8 ''nil)
                (emit `(sys.lap-x86:xor32 :ecx :ecx)
                      `(sys.lap-x86:mov64 :rbx :lsp))
                :multiple)
               (t (cg-form ''nil))))
        ((null (rest forms))
         ;; Single value.
         (let ((*for-value* t))
           (cg-form (first forms))))
        (t ;; Multiple-values
         (cond ((eql *for-value* :multiple)
                ;; The MV return convention happens to be almost identical
                ;; to the standard calling convention!
                (when (prep-arguments-for-call forms)
                  (load-constant :rcx (length forms))
                  (let ((stack-count (- (length forms) 5)))
                    (cond ((> stack-count 0)
                           (emit `(sys.lap-x86:lea64 :rbx (:lsp ,(* stack-count 8)))))
                          (t (emit `(sys.lap-x86:mov64 :rbx :lsp)))))
                  :multiple))
               (t ;; VALUES behaves like PROG1 when not compiling for multiple values.
                (let ((tag (cg-form (first forms))))
                  (unless tag (return-from cg-values nil))
                  (let ((*for-value* nil))
                    (dolist (f (rest forms))
                      (when (not (cg-form f))
                        (setf *load-list* (delete tag *load-list*))
                        (return-from cg-values nil))))
                  tag))))))

(defun cg-function-form (form)
  (let ((fn (when (not *suppress-builtins*)
              (match-builtin (first form) (length (rest form))))))
    (cond ((and (eql *for-value* :predicate)
                (or (eql (first form) 'null)
                    (eql (first form) 'not))
                (= (length form) 2))
           (let* ((tag (cg-form (second form)))
                  (loc (when (and tag (not (keywordp tag)))
                         (value-location tag t))))
             (cond ((null tag) nil)
                   ((keywordp tag)
                    ;; Invert the sense.
                    (invert-predicate tag))
                   ;; Perform (eql nil ...).
                   ((and (consp loc) (eq (first loc) :stack))
                    (emit `(sys.lap-x86:cmp64 (:stack ,(second loc)) nil))
                    :e)
                   (t (load-in-r8 tag)
                      (emit `(sys.lap-x86:cmp64 :r8 nil))
                      :e))))
          (fn
	   (let ((args '()))
	     (let ((*for-value* t))
	       (dolist (f (rest form))
		 (push (cg-form f) args)
		 (when (null (first args))
		   ;; Non-local control transfer, don't actually need those results now.
		   (dolist (i (rest args))
		     (setf *load-list* (delete i *load-list*)))
		   (return-from cg-function-form nil))))
	     (apply fn (nreverse args))))
	  ((and (eql (first form) 'funcall)
		(rest form))
	   (let* ((fn-tag (let ((*for-value* t)) (cg-form (second form))))
		  (type-error-label (gensym))
		  (function-label (gensym))
                  (out-label (gensym)))
	     (cond ((prep-arguments-for-call (cddr form))
		    (emit-trailer (type-error-label)
		      (raise-type-error :r13 '(or function symbol)))
		    (load-in-reg :r13 fn-tag t)
		    (smash-r8)
		    (load-constant :rcx (length (cddr form)))
		    (emit `(sys.lap-x86:mov8 :al :r13l)
			  `(sys.lap-x86:and8 :al #b1111)
			  `(sys.lap-x86:cmp8 :al ,sys.int::+tag-function+)
			  `(sys.lap-x86:je ,function-label)
			  `(sys.lap-x86:cmp8 :al ,sys.int::+tag-symbol+)
			  `(sys.lap-x86:jne ,type-error-label)
			  `(sys.lap-x86:call (:symbol-function :r13))
                          `(sys.lap-x86:jmp ,out-label)
			  function-label
			  `(sys.lap-x86:call :r13)
                          out-label)
                    (cond ((eql *for-value* :multiple)
                           :multiple)
                          (t (emit `(sys.lap-x86:mov64 :lsp :rbx))
                             (setf *r8-value* (list (gensym))))))
		   (t ;; Flush the unused function.
		    (setf *load-list* (delete fn-tag *load-list*))))))
          ((eql (first form) 'values)
           (cg-values (rest form)))
	  (t (when (prep-arguments-for-call (rest form))
	       (load-constant :r13 (first form))
	       (smash-r8)
	       (load-constant :rcx (length (rest form)))
	       (emit `(sys.lap-x86:call (:symbol-function :r13)))
               (cond ((eql *for-value* :multiple)
                      :multiple)
                     (t (emit `(sys.lap-x86:mov64 :lsp :rbx))
                        (setf *r8-value* (list (gensym))))))))))

;;; Locate a variable in the environment.
(defun find-var (var env chain)
  (assert chain (var env chain) "No environment chain?")
  (assert env (var env chain) "No environment?")
  (cond ((member var (first env))
         (values (first chain) 0 (position var (first env))))
        ((rest chain)
         (find-var var (rest env) (rest chain)))
        (t ;; Walk the environment using the current chain as a root.
         (let ((depth 0))
           (dolist (e (rest env)
                    (error "~S not found in environment?" var))
             (incf depth)
             (when (member var e)
               (return (values (first chain) depth
                               (position var e)))))))))

(defun cg-variable (form)
  (cond
    ((localp form)
     (cons form (incf *run-counter*)))
    (t ;; Non-local variable, requires an environment lookup.
     (multiple-value-bind (stack-slot depth offset)
         (find-var form *environment* *environment-chain*)
       (smash-r8)
       (emit `(sys.lap-x86:mov64 :r8 (:stack ,stack-slot)))
       (dotimes (n depth)
         (emit `(sys.lap-x86:mov64 :r8 (:r8 1))))
       (emit `(sys.lap-x86:mov64 :r8 (:r8 ,(1+ (* (1+ offset) 8)))))
       (setf *r8-value* (list (gensym)))))))

(defun cg-lambda (form)
  (let ((lap-code (codegen-lambda form)))
    (cond (*environment*
           ;; Allocate a closure using MAKE-CLOSURE.
           ;; TODO: Escape analysis for stack-allocated closures.
           (smash-r8)
           (load-constant :r8 lap-code)
           (load-constant :r13 'sys.int::make-closure)
           (emit `(sys.lap-x86:mov64 :r9 (:stack ,(first *environment-chain*)))
                 `(sys.lap-x86:mov32 :ecx 16)
                 `(sys.lap-x86:call (:symbol-function :r13))
                 `(sys.lap-x86:mov64 :lsp :rbx))
           (setf *r8-value* (list (gensym))))
          (t (list 'quote lap-code)))))

(defun raise-type-error (reg typespec)
  (unless (eql reg :r8)
    (emit `(sys.lap-x86:mov64 :r8 ,reg)))
  (load-constant :r9 typespec)
  (load-constant :r13 'sys.int::raise-type-error)
  (emit `(sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 2))
	`(sys.lap-x86:call (:symbol-function :r13))
	`(sys.lap-x86:ud2))
  nil)

(defun fixnum-check (reg &optional (typespec 'fixnum))
  (let ((type-error-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error reg typespec))
    (emit `(sys.lap-x86:test64 ,reg #b111)
	  `(sys.lap-x86:jnz ,type-error-label))))
