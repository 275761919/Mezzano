(defpackage #:system (:export #:lambda-name
                              #:io-port/8
                              #:char-bits
                              #:fixnump))
(defpackage #:system.internals
  (:nicknames #:sys.int)
  (:use #:cl))
(in-package #:system.compiler)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (shadow '(macro-function compiler-macro-function)))
(defun proclaimed-special-p (symbol)
  (sb-cltl2:variable-information symbol))
(import 'sb-cltl2:variable-information)
(define-condition sys.int::simple-style-warning (style-warning simple-condition)
  ())
(defun macro-function (symbol &optional env)
  (declare (ignore env))
  (cl:macro-function symbol))
(defun symbol-macro-function (symbol &optional env)
  (declare (ignore symbol env))
  nil)
(defun compiler-macro-function (symbol &optional env)
  (declare (ignore symbol env))
  nil)
(defun sys.int::function-symbol (name)
  (cond ((symbolp name)
         name)
        (t (or (get (second name) 'setf-symbol)
               (setf (get (second name) 'setf-symbol)
                     (make-symbol (format nil "~A" name)))))))
(declaim (declaration system:lambda-name))
(defun parse-ordinary-lambda-list (lambda-list)
  "Parse LAMBDA-LIST as an ordinary lambda list.
Returns the (required optional rest enable-keys keys allow-other-keys aux) elements
from the lambda-list or throws an error if the lambda-list is invalid."
  (let ((state :required)
	(required '())
	(optional '())
	(rest nil)
	(enable-keys nil)
	(keys '())
	(allow-other-keys nil)
	(aux '()))
    (dolist (i lambda-list)
      (ecase state
	(:required (case i
		     (&allow-other-keys
		      (error "Unexpected ~S in lambda list ~S" i lambda-list))
		     (&optional (setf state :optional))
		     (&rest (setf state :rest))
		     (&key (setf state :key
				 enable-keys t))
		     (&aux (setf state :aux))
		     (t (when (not (symbolp i))
			  (error "Required parameters must be symbols"))
			(push i required))))
	(:optional (case i
		     ((&optional &allow-other-keys)
		      (error "Unexpected ~S in lambda list ~S" i lambda-list))
		     (&rest (setf state :rest))
		     (&key (setf state :key
				 enable-keys t))
		     (&aux (setf state :aux))
		     (t (etypecase i
			  (symbol (push `(,i nil nil) optional))
			  (cons (let ((name (car i))
				      (default nil)
				      (supplied-p nil))
				  (unless (symbolp name)
				    (error "Invalid optional parameter ~S in lambda list ~S" i lambda-list))
				  (when (cdr i)
				    (unless (consp (cdr i))
				      (error "Invalid optional parameter ~S in lambda list ~S" i lambda-list))
				    (setf default (cadr i))
				    (when (cddr i)
				      (when (or (not (consp (cddr i)))
						(cdddr i)
						(null (caddr i))
						(not (symbolp (caddr i))))
					(error "Invalid optional parameter ~S in lambda list ~S" i lambda-list))
				      (setf supplied-p (caddr i))))
				  (push (list name default supplied-p) optional)))))))
	(:rest (case i
		 ((&optional &rest &key &allow-other-keys &aux)
		  (error "Unexpected ~S in lambda list ~S" i lambda-list))
		 ((nil) (error "Invalid &REST parameter name"))
		 (t (setf state :after-rest
			  rest i))))
	(:after-rest (case i
		       (&key (setf state :key
				   enable-keys t))
		       (&aux (setf state :aux))
		       (t (error "Unexpected ~S in lambda list ~S" i lambda-list))))
	(:key (case i
		((&optional &rest &key)
		  (error "Unexpected ~S in lambda list ~S" i lambda-list))
		(&allow-other-keys
		 (setf state :after-allow-other-keys
		       allow-other-keys t))
		(&aux (setf state :aux))
		(t (let (keyword name default supplied-p)
		     (etypecase i
		       (symbol (setf name i
				     keyword (intern (symbol-name i) "KEYWORD")))
		       (cons
			(if (consp (car i))
			    (if (or (not (symbolp (caar i)))
				    (not (consp (cdar i)))
				    (cddar i)
				    (not (symbolp (cadar i))))
				(error "Invalid key parameter ~S in lambda list ~S" i lambda-list)
				(setf name (cadar i)
				      keyword (caar i)))
			    (if (not (symbolp (car i)))
				(error "Invalid key parameter ~S in lambda list ~S" i lambda-list)
				(setf name (car i)
				      keyword (intern (symbol-name (car i)) "KEYWORD"))))
			(when (cdr i)
			  (unless (consp (cdr i))
			    (error "Invalid key parameter ~S in lambda list ~S" i lambda-list))
			  (setf default (cadr i))
			  (when (cddr i)
			    (setf supplied-p (caddr i))
			    (when (or (not (consp (cddr i)))
				      (cdddr i)
				      (null (caddr i))
				      (not (symbolp (caddr i))))
			      (error "Invalid key parameter ~S in lambda list ~S" i lambda-list))))))
		     (push (list (list keyword name) default supplied-p) keys)))))
	(:after-allow-other-keys
	 (if (eql i '&aux)
	     (setf state :aux)
	     (error "Unexpected ~S in lambda list ~S" i lambda-list)))
	(:aux (case i
		((&optional &rest &key &allow-other-keys &aux)
		 (error "Unexpected ~S in lambda list ~S" i lambda-list))
		(t (let (name default)
		     (etypecase i
		       (symbol (setf name i))
		       (cons
			(unless (symbolp (car i))
			  (error "Invalid aux parameter ~S in lambda list ~S" i lambda-list))
			(setf name (car i))
			(when (cdr i)
			  (when (or (not (consp (cdr i))) (cddr i))
			    (error "Invalid aux parameter ~S in lambda list ~S" i lambda-list))
			  (setf default (cadr i)))))
		     (push (list name default) aux)))))))
    (when (eql state :rest)
      (error "Missing &REST parameter name after &REST in lambda list ~S" lambda-list))
    (values (nreverse required) (nreverse optional) rest enable-keys (nreverse keys) allow-other-keys (nreverse aux))))

(in-package #:genesis)

(defun get-symbols-from-package (package-name)
  (let* ((p (genesis-eval (list (genesis-intern "FIND-PACKAGE") package-name)))
         (slots (genesis-struct-slots p))
         (internal-hash-table (aref (genesis-struct-slots (aref slots 5)) 7))
         (external-hash-table (aref (genesis-struct-slots (aref slots 6)) 7))
         (symbols (make-hash-table)))
    (flet ((frob (ht)
             (dotimes (i (/ (length ht) 2))
               (when (stringp (aref ht (* i 2)))
                 (setf (gethash (aref ht (1+ (* i 2))) symbols) t)))))
      (frob internal-hash-table)
      (frob external-hash-table))
    (alexandria:hash-table-keys symbols)))
