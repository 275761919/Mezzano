;;;; Functions which are built in to the compiler and have custom code generators.

(in-package #:system.compiler)

(defparameter *builtins* (make-hash-table))

(defmacro defbuiltin (name lambda-list (&optional (emit-function t)) &body body)
  `(progn (setf (gethash ',(sys.int::function-symbol name) *builtins*)
		(list ',lambda-list
		      (lambda ,lambda-list
			(declare (lambda-name ,name))
			,@body)
                      ',emit-function))
	  ',name))

(defmacro define-reader (name type tag slot)
  `(defbuiltin ,name (object) ()
     (let ((type-error-label (gensym)))
       (emit-trailer (type-error-label)
         (raise-type-error :r8 ',type))
       (load-in-reg :r8 object t)
       (smash-r8)
       (emit `(sys.lap-x86:mov8 :al :r8l)
             `(sys.lap-x86:and8 :al #b1111)
             `(sys.lap-x86:cmp8 :al ,,tag)
             `(sys.lap-x86:jne ,type-error-label)
             `(sys.lap-x86:mov64 :r8 (,',slot :r8)))
       (setf *r8-value* (list (gensym))))))

(defmacro define-writer (name type tag slot)
  `(defbuiltin ,name (value object) ()
     (let ((type-error-label (gensym)))
       (emit-trailer (type-error-label)
         (raise-type-error :r9 ',type))
       (load-in-reg :r9 object t)
       (load-in-reg :r8 value t)
       (emit `(sys.lap-x86:mov8 :al :r9l)
             `(sys.lap-x86:and8 :al #b1111)
             `(sys.lap-x86:cmp8 :al ,,tag)
             `(sys.lap-x86:jne ,type-error-label)
             `(sys.lap-x86:mov64 (,',slot :r9) :r8))
       *r8-value*)))

(defmacro define-accessor (name type tag slot)
  `(progn (define-reader ,name ,type ,tag ,slot)
          (define-writer (setf ,name) ,type ,tag ,slot)))

(defmacro define-tag-type-predicate (name tag)
  `(defbuiltin ,name (object) ()
     (load-in-reg :r8 object t)
     (emit `(sys.lap-x86:mov8 :al :r8l)
           `(sys.lap-x86:and8 :al #b1111)
           `(sys.lap-x86:cmp8 :al ,,tag))
     (predicate-result :e)))

;; Produce an alist of symbol names and their associated functions.
(defun generate-builtin-functions ()
  (let ((functions '()))
    (maphash (lambda (name fn)
               (when (third fn)
                 (push (list name
                             `(lambda ,(first fn)
                                (declare (system:lambda-name ,name))
                                (,name ,@(first fn))))
                       functions)))
             *builtins*)
    functions))

(defun match-builtin (symbol arg-count)
  (let ((x (gethash symbol *builtins*)))
    (when (and x (eql (length (first x)) arg-count))
      (second x))))

(defun constant-type-p (tag type)
  (and (consp tag)
       (consp (cdr tag))
       (null (cddr tag))
       (eql (first tag) 'quote)
       (typep (second tag) type)))

(defbuiltin sys.int::memref-unsigned-byte-8 (base offset) ()
  (let ((type-error-label (gensym)))
    (load-in-reg :rax base t)
    (fixnum-check :rax)
    (load-in-reg :rcx offset t)
    (fixnum-check :rcx)
    (smash-r8)
    (emit ;; Convert to raw integers, leaving offset correctly scaled (* 1).
	  `(sys.lap-x86:sar64 :rax 3)
	  `(sys.lap-x86:sar64 :rcx 3)
	  ;; Read.
	  `(sys.lap-x86:mov8 :dl (:rax :rcx))
          ;; Convert to fixnum.
          `(sys.lap-x86:and32 :edx #xFF)
          `(sys.lap-x86:shl32 :edx 3)
          `(sys.lap-x86:mov32 :r8d :edx))
    (setf *r8-value* (list (gensym)))))

(defbuiltin sys.int::memref-unsigned-byte-16 (base offset) ()
  (let ((type-error-label (gensym)))
    (load-in-reg :rax base t)
    (fixnum-check :rax)
    (load-in-reg :rcx offset t)
    (fixnum-check :rcx)
    (smash-r8)
    (emit ;; Convert to raw integers, leaving offset correctly scaled (* 2).
	  `(sys.lap-x86:sar64 :rax 3)
	  `(sys.lap-x86:sar64 :rcx 2)
	  ;; Read.
	  `(sys.lap-x86:mov16 :dx (:rax :rcx))
          ;; Convert to fixnum.
          `(sys.lap-x86:and32 :edx #xFFFF)
          `(sys.lap-x86:shl32 :edx 3)
          `(sys.lap-x86:mov32 :r8d :edx))
    (setf *r8-value* (list (gensym)))))

(defbuiltin sys.int::memref-unsigned-byte-32 (base offset) ()
  (let ((type-error-label (gensym)))
    (load-in-reg :rax base t)
    (fixnum-check :rax)
    (load-in-reg :rcx offset t)
    (fixnum-check :rcx)
    (smash-r8)
    (emit ;; Convert to raw integers, leaving offset correctly scaled (* 4).
	  `(sys.lap-x86:sar64 :rax 3)
	  `(sys.lap-x86:sar64 :rcx 1)
	  ;; Read.
	  `(sys.lap-x86:mov32 :edx (:rax :rcx))
          ;; Convert to fixnum.
          `(sys.lap-x86:shl64 :rdx 3)
          `(sys.lap-x86:mov64 :r8 :rdx))
    (setf *r8-value* (list (gensym)))))

(defbuiltin (setf sys.int::memref-unsigned-byte-8) (new-value base offset) ()
  (let ((type-error-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :rdx '(unsigned-byte 8)))
    (load-in-reg :rax base t)
    (fixnum-check :rax)
    (load-in-reg :rcx offset t)
    (fixnum-check :rcx)
    (load-in-r8 new-value t)
    (emit `(sys.lap-x86:mov64 :rdx :r8)
	  `(sys.lap-x86:test64 :rdx #b111)
	  `(sys.lap-x86:jnz ,type-error-label)
	  `(sys.lap-x86:cmp64 :rdx ,(* #x100 8))
	  `(sys.lap-x86:jae ,type-error-label)
	  ;; Convert to raw integers, leaving offset correctly scaled (* 1).
	  `(sys.lap-x86:sar64 :rax 3)
	  `(sys.lap-x86:sar64 :rcx 3)
	  `(sys.lap-x86:sar64 :rdx 3)
	  ;; Write.
	  `(sys.lap-x86:mov8 (:rax :rcx) :dl))
    *r8-value*))

(defbuiltin (setf sys.int::memref-unsigned-byte-16) (new-value base offset) ()
  (let ((type-error-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :rdx '(unsigned-byte 16)))
    (load-in-reg :rax base t)
    (fixnum-check :rax)
    (load-in-reg :rcx offset t)
    (fixnum-check :rcx)
    (load-in-r8 new-value t)
    (emit `(sys.lap-x86:mov64 :rdx :r8)
	  `(sys.lap-x86:test64 :rdx #b111)
	  `(sys.lap-x86:jnz ,type-error-label)
	  `(sys.lap-x86:cmp64 :rdx ,(* #x10000 8))
	  `(sys.lap-x86:jae ,type-error-label)
	  ;; Convert to raw integers, leaving offset correctly scaled (* 2).
	  `(sys.lap-x86:sar64 :rax 3)
	  `(sys.lap-x86:sar64 :rcx 2)
	  `(sys.lap-x86:sar64 :rdx 3)
	  ;; Write.
	  `(sys.lap-x86:mov16 (:rax :rcx) :dx))
    *r8-value*))

(defbuiltin (setf sys.int::memref-unsigned-byte-32) (new-value base offset) ()
  (let ((type-error-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :rdx '(unsigned-byte 32)))
    (load-in-reg :rax base t)
    (fixnum-check :rax)
    (load-in-reg :rcx offset t)
    (fixnum-check :rcx)
    (load-in-r8 new-value t)
    (emit `(sys.lap-x86:mov64 :rdx :r8)
	  `(sys.lap-x86:test64 :rdx #b111)
	  `(sys.lap-x86:jnz ,type-error-label)
          `(sys.lap-x86:mov64 :rsi ,(* #x100000000 8))
	  `(sys.lap-x86:cmp64 :rdx :rsi)
	  `(sys.lap-x86:jae ,type-error-label)
	  ;; Convert to raw integers, leaving offset correctly scaled (* 2).
	  `(sys.lap-x86:sar64 :rax 3)
	  `(sys.lap-x86:sar64 :rcx 1)
	  `(sys.lap-x86:sar64 :rdx 3)
	  ;; Write.
	  `(sys.lap-x86:mov32 (:rax :rcx) :edx))
    *r8-value*))

(defbuiltin sys.int::memref-unsigned-byte-64 (base offset) ()
  (let ((overflow-error-label (gensym))
        (ok-label (gensym)))
    (emit-trailer (overflow-error-label)
      (load-constant :r10 'sys.int::memref-unsigned-byte-64)
      (load-constant :r13 'sys.int::raise-overflow)
      (emit `(sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 2))
	    `(sys.lap-x86:call (:symbol-function :r13))
	    `(sys.lap-x86:ud2)))
    (load-in-reg :r8 base t)
    (fixnum-check :r8)
    (load-in-reg :r9 offset t)
    (fixnum-check :r9)
    (smash-r8)
    (emit `(sys.lap-x86:mov64 :rax :r8)
          `(sys.lap-x86:mov64 :rcx :r9)
	  ;; Convert to raw integers, leaving offset correctly scaled (* 8).
	  `(sys.lap-x86:sar64 :rax 3)
          ;; Read.
          `(sys.lap-x86:mov64 :rax (:rax :rcx))
          ;; Check for overflow. Top 3 bits must be all 0 or all 1.
          `(sys.lap-x86:mov64 :rdx :rax)
          `(sys.lap-x86:sar64 :rdx 61)
          `(sys.lap-x86:jz ,ok-label)
          `(sys.lap-x86:cmp8 :dl -1)
          `(sys.lap-x86:jne ,overflow-error-label)
          ok-label
          ;; Convert to fixnum.
          `(sys.lap-x86:shl64 :rax 3)
          `(sys.lap-x86:mov64 :r8 :rax))
    (setf *r8-value* (list (gensym)))))

;;; TODO: bignums.
(defbuiltin (setf sys.int::memref-unsigned-byte-64) (new-value base offset) ()
  (let ((type-error-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :r8 '(unsigned-byte 64)))
    (load-in-reg :rax base t)
    (fixnum-check :rax)
    (load-in-reg :rcx offset t)
    (fixnum-check :rcx)
    (load-in-r8 new-value t)
    (emit `(sys.lap-x86:mov64 :rdx :r8)
	  `(sys.lap-x86:test64 :rdx #b111)
	  `(sys.lap-x86:jnz ,type-error-label)
	  ;; Convert to raw integers, leaving offset correctly scaled (* 8).
	  `(sys.lap-x86:sar64 :rax 3)
	  `(sys.lap-x86:sar64 :rdx 3)
	  ;; Write.
	  `(sys.lap-x86:mov64 (:rax :rcx) :rdx))
    *r8-value*))

(defbuiltin sys.int::memref-t (base offset) ()
  (let ((type-error-label (gensym)))
    (load-in-reg :rax base t)
    (fixnum-check :rax)
    (load-in-reg :rcx offset t)
    (fixnum-check :rcx)
    (smash-r8)
    (emit ;; Convert to raw integers, leaving offset correctly scaled (* 8).
	  `(sys.lap-x86:sar64 :rax 3)
	  ;; Read.
	  `(sys.lap-x86:mov64 :r8 (:rax :rcx)))
    (setf *r8-value* (list (gensym)))))

(defbuiltin (setf sys.int::memref-t) (new-value base offset) ()
  (let ((type-error-label (gensym)))
    (load-in-reg :rax base t)
    (fixnum-check :rax)
    (load-in-reg :rcx offset t)
    (fixnum-check :rcx)
    (load-in-r8 new-value t)
    (emit ;; Convert to raw integers, leaving offset correctly scaled (* 8).
	  `(sys.lap-x86:sar64 :rax 3)
	  ;; Write.
	  `(sys.lap-x86:mov64 (:rax :rcx) :r8))
    *r8-value*))

(defbuiltin sys.int::%simple-array-p (object) ()
  (let ((false-out (gensym))
        (out (gensym)))
    (load-in-reg :r8 object t)
    (emit `(sys.lap-x86:mov8 :al :r8l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-array-like+)
          `(sys.lap-x86:jne ,false-out)
          `(sys.lap-x86:mov8 :al (:simple-array-header :r8))
          `(sys.lap-x86:cmp8 :al ,(ash sys.int::+last-array-type+ 1))
          `(sys.lap-x86:jnbe ,false-out)
          `(sys.lap-x86:mov64 :r8 t)
          `(sys.lap-x86:jmp ,out)
          false-out
          `(sys.lap-x86:mov64 :r8 nil)
          out)
    (setf *r8-value* (list (gensym)))))

(defbuiltin sys.int::%simple-array-length (array) ()
  (let ((type-error-label (gensym)))
    (emit-trailer (type-error-label)
		  (raise-type-error :r8 '(simple-array * (*))))
    (load-in-r8 array t)
    (smash-r8)
    (emit `(sys.lap-x86:mov8 :al :r8l)
	  `(sys.lap-x86:and8 :al #b1111)
	  `(sys.lap-x86:cmp8 :al ,sys.int::+tag-array-like+)
	  `(sys.lap-x86:jne ,type-error-label)
	  ;; Ensure that it is a simple-array, not a struct or bignum or similar.
	  `(sys.lap-x86:mov64 :rax (:simple-array-header :r8))
	  `(sys.lap-x86:cmp8 :al ,(ash sys.int::+last-array-type+ 1))
	  `(sys.lap-x86:jnbe ,type-error-label)
	  ;; Convert length to fixnum.
	  `(sys.lap-x86:shr64 :rax 5)
	  `(sys.lap-x86:and64 :rax -8)
	  `(sys.lap-x86:mov64 :r8 :rax))
    (setf *r8-value* (list (gensym)))))

(defbuiltin sys.int::%simple-array-type (array) ()
  (let ((type-error-label (gensym)))
    (emit-trailer (type-error-label)
		  (raise-type-error :r8 '(simple-array * (*))))
    (load-in-r8 array t)
    (smash-r8)
    (emit `(sys.lap-x86:mov8 :al :r8l)
	  `(sys.lap-x86:and8 :al #b1111)
	  `(sys.lap-x86:cmp8 :al ,sys.int::+tag-array-like+)
	  `(sys.lap-x86:jne ,type-error-label)
	  ;; Ensure that it is a simple-array, not a struct or bignum or similar.
	  `(sys.lap-x86:mov8 :al (:simple-array-header :r8))
	  `(sys.lap-x86:cmp8 :al ,(ash sys.int::+last-array-type+ 1))
	  `(sys.lap-x86:jnbe ,type-error-label)
	  ;; Convert tag to fixnum. Low bit is the GC bit, always clear.
          `(sys.lap-x86:and32 :eax #x000000FE)
	  `(sys.lap-x86:shl32 :eax 2)
	  `(sys.lap-x86:mov32 :r8d :eax))
    (setf *r8-value* (list (gensym)))))

(defbuiltin sys.int::binary-logior (x y) ()
  (when (constant-type-p y 'fixnum)
    (psetf x y
           y x))
  (cond ((constant-type-p x 'fixnum)
	 (load-in-r8 y t)
	 (fixnum-check :r8)
         (smash-r8)
	 ;; Small integers can be encoded directly into the instruction.
	 (if (typep (second x) '(signed-byte 28))
	     (emit `(sys.lap-x86:or64 :r8 ,(fixnum-to-raw (second x))))
	     (emit `(sys.lap-x86:mov64 :rax ,(fixnum-to-raw (second x)))
		   `(sys.lap-x86:or64 :r8 :rax)))
	 (setf *r8-value* (list (gensym))))
	(t (load-in-reg :r9 y t)
           (fixnum-check :r9)
           (load-in-reg :r8 x t)
           (fixnum-check :r8)
           (smash-r8)
           (emit `(sys.lap-x86:or64 :r8 :r9))
           (setf *r8-value* (list (gensym))))))

(defbuiltin sys.int::binary-logxor (x y) ()
  (when (constant-type-p y 'fixnum)
    (psetf x y
           y x))
  (cond ((constant-type-p x 'fixnum)
	 (load-in-r8 y t)
	 (fixnum-check :r8)
         (smash-r8)
	 ;; Small integers can be encoded directly into the instruction.
	 (if (typep (second x) '(signed-byte 28))
	     (emit `(sys.lap-x86:xor64 :r8 ,(fixnum-to-raw (second x))))
	     (emit `(sys.lap-x86:mov64 :rax ,(fixnum-to-raw (second x)))
		   `(sys.lap-x86:xor64 :r8 :rax)))
	 (setf *r8-value* (list (gensym))))
	(t (load-in-reg :r9 y t)
           (fixnum-check :r9)
           (load-in-reg :r8 x t)
           (fixnum-check :r8)
           (smash-r8)
           (emit `(sys.lap-x86:xor64 :r8 :r9))
           (setf *r8-value* (list (gensym))))))

(defbuiltin sys.int::binary-logand (x y) ()
  (let ((full-logand (gensym))
        (resume (gensym)))
    (when (constant-type-p y 'fixnum)
      (psetf x y
             y x))
    (emit-trailer (full-logand)
      (when (constant-type-p x 'fixnum)
        (load-constant :r9 (second x)))
      (emit `(sys.lap-x86:mov32 :ecx 16)
            `(sys.lap-x86:mov64 :r13 (:constant sys.int::generic-logand))
            `(sys.lap-x86:call (:symbol-function :r13))
            `(sys.lap-x86:mov64 :lsp :rbx)
            `(sys.lap-x86:jmp ,resume)))
    (cond ((constant-type-p x 'fixnum)
           (load-in-r8 y t)
           (smash-r8)
           (emit `(sys.lap-x86:test64 :r8 7)
                 `(sys.lap-x86:jnz ,full-logand))
           ;; Small integers can be encoded directly into the instruction.
           (if (typep (second x) '(signed-byte 28))
               (emit `(sys.lap-x86:and64 :r8 ,(fixnum-to-raw (second x))))
               (emit `(sys.lap-x86:mov64 :rax ,(fixnum-to-raw (second x)))
                     `(sys.lap-x86:and64 :r8 :rax)))
           (emit resume)
           (setf *r8-value* (list (gensym))))
          (t (load-in-reg :r9 y t)
             (load-in-reg :r8 x t)
             (smash-r8)
             (emit `(sys.lap-x86:test64 :r8 7)
                   `(sys.lap-x86:jnz ,full-logand)
                   `(sys.lap-x86:test64 :r9 7)
                   `(sys.lap-x86:jnz ,full-logand)
                   `(sys.lap-x86:and64 :r8 :r9)
                   resume)
             (setf *r8-value* (list (gensym)))))))

(defbuiltin lognot (integer) ()
  (load-in-reg :r8 integer t)
  (fixnum-check :r8)
  (smash-r8)
  (emit `(sys.lap-x86:xor64 :r8 -8))
  (setf *r8-value* (list (gensym))))

(defbuiltin sys.int::binary-+ (x y) ()
  (let ((ovfl (gensym "+ovfl"))
        (resume (gensym "+resume"))
        (full-add (gensym "+full")))
    (when (constant-type-p y 'fixnum)
      (psetf x y
             y x))
    (emit-trailer (ovfl)
      ;; Recover the full value using the carry bit.
      (emit `(sys.lap-x86:mov64 :rax :r8)
            `(sys.lap-x86:rcr64 :rax 1)
            ;; Drop the two remaining fixnum tag bits.
            `(sys.lap-x86:sar64 :rax 2)
            ;; Call assembly helper function.
            `(sys.lap-x86:mov64 :r13 (:constant sys.int::%%make-bignum-64-rax))
            `(sys.lap-x86:call (:symbol-function :r13))
            `(sys.lap-x86:jmp ,resume)))
    (emit-trailer (full-add)
      (when (constant-type-p x 'fixnum)
        (load-constant :r9 x))
      (emit `(sys.lap-x86:mov32 :ecx 16)
            `(sys.lap-x86:mov64 :r13 (:constant sys.int::generic-+))
            `(sys.lap-x86:call (:symbol-function :r13))
            `(sys.lap-x86:mov64 :lsp :rbx)
            `(sys.lap-x86:jmp ,resume)))
    (cond ((constant-type-p x 'fixnum)
           (load-in-r8 y t)
           (emit `(sys.lap-x86:test64 :r8 7)
                 `(sys.lap-x86:jnz ,full-add))
           (smash-r8)
           ;; Small integers can be encoded directly into the instruction.
           (if (typep (second x) '(signed-byte 28))
               (emit `(sys.lap-x86:add64 :r8 ,(fixnum-to-raw (second x))))
               (emit `(sys.lap-x86:mov64 :rax ,(fixnum-to-raw (second x)))
                     `(sys.lap-x86:add64 :r8 :rax))))
          (t (load-in-reg :r9 y t)
             (load-in-reg :r8 x t)
             (emit `(sys.lap-x86:test64 :r9 7)
                   `(sys.lap-x86:jnz ,full-add)
                   `(sys.lap-x86:test64 :r8 7)
                   `(sys.lap-x86:jnz ,full-add))
             (smash-r8)
             (emit `(sys.lap-x86:add64 :r8 :r9))))
    (emit `(sys.lap-x86:jo ,ovfl)
          resume)
    (setf *r8-value* (list (gensym)))))

(defbuiltin sys.int::binary-- (x y) ()
  (let ((ovfl (gensym "-ovfl"))
        (resume (gensym "-resume"))
        (full-sub (gensym "-full")))
    (emit-trailer (ovfl)
      ;; Recover the full value.
      (emit `(sys.lap-x86:cmc)
            `(sys.lap-x86:mov64 :rax :r8)
            `(sys.lap-x86:rcr64 :rax 1)
            ;; Drop the two remaining fixnum tag bits.
            `(sys.lap-x86:sar64 :rax 2)
            ;; Call assembly helper function.
            `(sys.lap-x86:mov64 :r13 (:constant sys.int::%%make-bignum-64-rax))
            `(sys.lap-x86:call (:symbol-function :r13))
            `(sys.lap-x86:jmp ,resume)))
    (emit-trailer (full-sub)
      (emit `(sys.lap-x86:mov32 :ecx 16)
            `(sys.lap-x86:mov64 :r13 (:constant sys.int::generic--))
            `(sys.lap-x86:call (:symbol-function :r13))
            `(sys.lap-x86:mov64 :lsp :rbx)
            `(sys.lap-x86:jmp ,resume)))
    (load-in-reg :r8 x t)
    (load-in-reg :r9 y t)
    (smash-r8)
    (emit `(sys.lap-x86:test64 :r8 7)
          `(sys.lap-x86:jnz ,full-sub)
          `(sys.lap-x86:test64 :r9 7)
          `(sys.lap-x86:jnz ,full-sub)
          `(sys.lap-x86:sub64 :r8 :r9)
          `(sys.lap-x86:jo ,ovfl)
          resume)
    (setf *r8-value* (list (gensym)))))

(defbuiltin sys.int::binary-* (x y) ()
  (let ((ovfl (gensym "*ovfl"))
        (resume (gensym "*resume"))
        (full-mul (gensym "*full"))
        (small-bignum (gensym "*small-result")))
    (emit-trailer (ovfl)
      ;; 128-bit result in rdx:rax.
      ;; Unbox the result.
      (emit `(sys.lap-x86:shrd64 :rax :rdx 3)
            ;; Check if the result will fit in 64 bits.
            ;; Save the high bits.
            `(sys.lap-x86:mov64 :rcx :rdx)
            `(sys.lap-x86:cqo)
            `(sys.lap-x86:cmp64 :rcx :rdx)
            `(sys.lap-x86:je ,small-bignum)
            ;; Nope.
            `(sys.lap-x86:mov64 :rdx :rcx)
            `(sys.lap-x86:mov64 :r13 (:constant sys.int::%%make-bignum-128-rdx-rax))
            `(sys.lap-x86:call (:symbol-function :r13))
            `(sys.lap-x86:jmp ,resume)
            small-bignum
            ;; Yup.
            `(sys.lap-x86:mov64 :r13 (:constant sys.int::%%make-bignum-64-rax))
            `(sys.lap-x86:call (:symbol-function :r13))
            `(sys.lap-x86:jmp ,resume)))
    (emit-trailer (full-mul)
      (emit `(sys.lap-x86:mov32 :ecx 16)
            `(sys.lap-x86:mov64 :r13 (:constant sys.int::generic-*))
            `(sys.lap-x86:call (:symbol-function :r13))
            `(sys.lap-x86:mov64 :lsp :rbx)
            `(sys.lap-x86:jmp ,resume)))
    (load-in-reg :r9 y t)
    (load-in-reg :r8 x t)
    (smash-r8)
    (emit `(sys.lap-x86:test64 :r8 7)
          `(sys.lap-x86:jnz ,full-mul)
          `(sys.lap-x86:test64 :r9 7)
          `(sys.lap-x86:jnz ,full-mul)
          `(sys.lap-x86:mov64 :rax :r8)
          ;; Convert RAX to raw integer.
          `(sys.lap-x86:sar64 :rax 3)
          `(sys.lap-x86:imul64 :r9)
          `(sys.lap-x86:jo ,ovfl)
          ;; R9 was not converted to a raw integer, so the result
          ;; was automatically converted to a fixnum.
          `(sys.lap-x86:mov64 :r8 :rax)
          resume)
    (setf *r8-value* (list (gensym)))))

;; FIXME: default divisor to 1
(defbuiltin rem (number divisor) ()
  (let ((full-rem (gensym "full-rem"))
        (resume (gensym "resume-rem")))
    (emit-trailer (full-rem)
      (emit `(sys.lap-x86:mov32 :ecx 16)
            `(sys.lap-x86:mov64 :r13 (:constant sys.int::generic-rem))
            `(sys.lap-x86:call (:symbol-function :r13))
            `(sys.lap-x86:mov64 :lsp :rbx)
            `(sys.lap-x86:jmp ,resume)))
    (load-in-reg :r9 divisor t)
    (load-in-reg :r8 number t)
    (smash-r8)
    (emit `(sys.lap-x86:test64 :r8 7)
          `(sys.lap-x86:jnz ,full-rem)
          `(sys.lap-x86:test64 :r9 7)
          `(sys.lap-x86:jnz ,full-rem)
          ;; Bail out to the full REM on /0.
          `(sys.lap-x86:test64 :r9 :r9)
          `(sys.lap-x86:jz ,full-rem)
          ;; Don't check for REM -1, don't care about the quotient.
          `(sys.lap-x86:mov64 :rax :r8)
          `(sys.lap-x86:cqo)
          `(sys.lap-x86:idiv64 :r9)
          ;; :rdx holds the remainder as a fixnum.
          `(sys.lap-x86:mov64 :r8 :rdx)
          resume)
    (setf *r8-value* (list (gensym)))))

;; FIXME: default divisor to 1
(defbuiltin truncate (number divisor) ()
  (let ((full-truncate (gensym "full-truncate"))
        (resume (gensym "resume-truncate")))
    (emit-trailer (full-truncate)
      (emit `(sys.lap-x86:mov32 :ecx 16)
            `(sys.lap-x86:mov64 :r13 (:constant sys.int::generic-truncate))
            `(sys.lap-x86:call (:symbol-function :r13)))
      (unless (eql *for-value* :multiple)
        (emit `(sys.lap-x86:mov64 :lsp :rbx)))
      (emit `(sys.lap-x86:jmp ,resume)))
    (load-in-reg :r9 divisor t)
    (load-in-reg :r8 number t)
    (smash-r8)
    (emit `(sys.lap-x86:test64 :r8 7)
          `(sys.lap-x86:jnz ,full-truncate)
          `(sys.lap-x86:test64 :r9 7)
          `(sys.lap-x86:jnz ,full-truncate)
          ;; Bail out to the full truncate when /0 or /-1.
          `(sys.lap-x86:test64 :r9 :r9)
          `(sys.lap-x86:jz ,full-truncate)
          `(sys.lap-x86:cmp64 :r9 -8)
          `(sys.lap-x86:je ,full-truncate)
          `(sys.lap-x86:mov64 :rax :r8)
          `(sys.lap-x86:cqo)
          `(sys.lap-x86:idiv64 :r9)
          ;; :rax holds the dividend as a integer.
          ;; :rdx holds the remainder as a fixnum.
          `(sys.lap-x86:shl64 :rax 3)
          `(sys.lap-x86:mov64 :r8 :rax))
    (prog1 (cond ((eql *for-value* :multiple)
                  (emit `(sys.lap-x86:mov64 :r9 :rdx)
                        `(sys.lap-x86:mov64 :rbx :lsp))
                  (load-constant :rcx 2)
                  :multiple)
                 (t (setf *r8-value* (list (gensym)))))
      (emit resume))))

(defbuiltin ash (integer count) ()
  (cond ((constant-type-p count 'fixnum)
         (setf count (second count))
         (load-in-reg :r8 integer t)
         (fixnum-check :r8)
         (cond ((minusp count)
                ;; Right shift.
                (setf count (- count))
                (smash-r8)
                (cond ((>= count 61)
                       ;; All bits shifted out.
                       (emit `(sys.lap-x86:cqo)
                             `(sys.lap-x86:and64 :rdx -8)
                             `(sys.lap-x86:mov64 :r8 :rdx)))
                      (t (emit `(sys.lap-x86:mov64 :rax :r8)
                               `(sys.lap-x86:sar64 :rax ,count)
                               `(sys.lap-x86:and64 :rax -8)
                               `(sys.lap-x86:mov64 :r8 :rax))))
                (setf *r8-value* (list (gensym))))
               ((plusp count)
                ;; Left shift.
                ;; Perform the shift one bit at a time so that overflow can be checked for.
                (let ((ovfl (gensym)))
                  (emit-trailer (ovfl)
                    (load-constant :r9 count)
                    (load-constant :r10 'ash)
                    (load-constant :r13 'sys.int::raise-overflow)
                    (emit `(sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 3))
                          `(sys.lap-x86:call (:symbol-function :r13))
                          `(sys.lap-x86:ud2)))
                  (smash-r8)
                  (dotimes (i count)
                    (emit `(sys.lap-x86:shl64 :r8 1)
                          `(sys.lap-x86:jo ,ovfl)))
                  (setf *r8-value* (list (gensym)))))
               ((zerop count)
                ;; Type check only.
                integer)))
        (t (let ((done-label (gensym))
                 (shift-left (gensym))
                 (shift-right (gensym))
                 (sign-extend (gensym))
                 (ovfl (gensym)))
             (emit-trailer (ovfl)
                           (load-constant :r10 'ash)
                           (load-constant :r13 'sys.int::raise-overflow)
                           (emit `(sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 3))
                                 `(sys.lap-x86:call (:symbol-function :r13))
                                 `(sys.lap-x86:ud2)))
             (load-in-reg :r9 count t)
             (fixnum-check :r9)
             (load-in-reg :r8 integer t)
             (smash-r8)
             (fixnum-check :r8)
             (emit `(sys.lap-x86:mov64 :rcx :r9)
                   `(sys.lap-x86:mov64 :rax :r8)
                   `(sys.lap-x86:cmp64 :rcx 0)
                   `(sys.lap-x86:jz ,done-label)
                   `(sys.lap-x86:jl ,shift-right)
                   ;; Left shift.
                   ;; Perform the shift one bit at a time so that overflow can be checked for.
                   `(sys.lap-x86:sar64 :rcx 3)
                   shift-left
                   `(sys.lap-x86:shl64 :rax 1)
                   `(sys.lap-x86:jo ,ovfl)
                   `(sys.lap-x86:sub64 :rcx 1)
                   `(sys.lap-x86:jnz ,shift-left)
                   `(sys.lap-x86:jmp ,done-label)
                   ;; x86 masks the shift count to 6 bits, test if all the bits were shifted out.
                   shift-right
                   `(sys.lap-x86:cmp64 :rcx ,(fixnum-to-raw -64))
                   `(sys.lap-x86:jle ,sign-extend)
                   `(sys.lap-x86:sar64 :rcx 3)
                   `(sys.lap-x86:neg64 :rcx)
                   `(sys.lap-x86:sar64 :rax :cl)
                   `(sys.lap-x86:and64 :rax -8)
                   `(sys.lap-x86:jmp ,done-label)
                   sign-extend
                   `(sys.lap-x86:cqo)
                   `(sys.lap-x86:and64 :rdx -8)
                   `(sys.lap-x86:mov64 :rax :rdx)
                   done-label
                   `(sys.lap-x86:mov64 :r8 :rax))
             (setf *r8-value* (list (gensym)))))))

(defmacro define-conditional-builtin (name generic-name conditional)
  `(defbuiltin ,name (x y) ()
     (let ((generic (gensym))
           (resume (gensym)))
       (emit-trailer (generic)
         (emit `(sys.lap-x86:mov32 :ecx 16)
               `(sys.lap-x86:mov64 :r13 (:constant ,',generic-name))
               `(sys.lap-x86:call (:symbol-function :r13))
               `(sys.lap-x86:mov64 :lsp :rbx)
               `(sys.lap-x86:jmp ,resume)))
       (load-in-reg :r9 y t)
       (load-in-reg :r8 x t)
       (smash-r8)
       (emit `(sys.lap-x86:test64 :r8 7)
             `(sys.lap-x86:jnz ,generic)
             `(sys.lap-x86:test64 :r9 7)
             `(sys.lap-x86:jnz ,generic)
             `(sys.lap-x86:cmp64 :r8 :r9)
             `(sys.lap-x86:mov64 :r8 nil)
             `(sys.lap-x86:mov64 :r9 t)
             `(,',(fourth (predicate-info conditional)) :r8 :r9)
             resume)
       (setf *r8-value* (list (gensym))))))

(define-conditional-builtin sys.int::binary-< sys.int::generic-< :l)
(define-conditional-builtin sys.int::binary->= sys.int::generic->= :ge)
(define-conditional-builtin sys.int::binary-> sys.int::generic-> :g)
(define-conditional-builtin sys.int::binary-<= sys.int::generic-<= :le)
(define-conditional-builtin sys.int::binary-= sys.int::generic-= :e)

(defbuiltin schar (string index) ()
  (let ((bound-error-label (gensym))
	(type-error-label (gensym))
	(base-string-label (gensym))
	(out-label (gensym)))
    (emit-trailer (bound-error-label)
      (load-constant :r13 'sys.int::raise-bound-error)
      (emit `(sys.lap-x86:mov64 :r9 :rax)
	    `(sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 2))
	    `(sys.lap-x86:call (:symbol-function :r13))
	    `(sys.lap-x86:ud2)))
    (emit-trailer (type-error-label)
      (raise-type-error :r8 'simple-string))
    (load-in-reg :rax index t)
    (fixnum-check :rax)
    (load-in-r8 string t)
    (smash-r8)
    (emit `(sys.lap-x86:mov64 :rdx :rax)
	  `(sys.lap-x86:sar64 :rdx 3)
	  `(sys.lap-x86:mov8 :cl :r8l)
	  `(sys.lap-x86:and8 :cl #b1111)
	  `(sys.lap-x86:cmp8 :cl ,sys.int::+tag-array-like+)
	  `(sys.lap-x86:jne ,type-error-label)
	  ;; Ensure that it is a simple-string.
	  `(sys.lap-x86:mov64 :rcx (:simple-array-header :r8))
	  `(sys.lap-x86:cmp8 :cl ,(ash sys.int::+array-type-base-char+ 1))
	  `(sys.lap-x86:je ,base-string-label)
	  `(sys.lap-x86:cmp8 :cl ,(ash sys.int::+array-type-character+ 1))
	  `(sys.lap-x86:jne ,type-error-label)
	  ;; simple-string (not simple-base-string).
	  `(sys.lap-x86:shr64 :rcx 8)
	  `(sys.lap-x86:cmp64 :rdx :rcx)
	  `(sys.lap-x86:jae ,bound-error-label)
	  `(sys.lap-x86:mov32 :eax (:r8 1 (:rdx 4)))
	  `(sys.lap-x86:jmp ,out-label)
	  ;; simple-base-string.
	  base-string-label
	  `(sys.lap-x86:shr64 :rcx 8)
	  `(sys.lap-x86:cmp64 :rdx :rcx)
	  `(sys.lap-x86:jae ,bound-error-label)
	  `(sys.lap-x86:xor32 :eax :eax)
	  `(sys.lap-x86:mov8 :al (:r8 1 :rdx))
	  out-label
	  ;; Convert EAX to a real character.
	  `(sys.lap-x86:shl32 :eax 4)
	  `(sys.lap-x86:or32 :eax ,sys.int::+tag-character+)
	  `(sys.lap-x86:mov32 :r8d :eax))
    (setf *r8-value* (list (gensym)))))

(defbuiltin (setf schar) (value string index) ()
  (let ((bound-error-label (gensym))
	(type-error-label (gensym))
	(char-type-error-label (gensym))
	(base-char-type-error-label (gensym))
	(base-string-label (gensym))
	(out-label (gensym)))
    (emit-trailer (bound-error-label)
      (load-constant :r13 'sys.int::raise-bound-error)
      (emit `(sys.lap-x86:mov64 :r9 :rax)
	    `(sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 2))
	    `(sys.lap-x86:call (:symbol-function :r13))
	    `(sys.lap-x86:ud2)))
    (emit-trailer (type-error-label)
      (raise-type-error :r9 'simple-string))
    (emit-trailer (char-type-error-label)
      (raise-type-error :r8 'character))
    (emit-trailer (base-char-type-error-label)
      (raise-type-error :r8 'base-char))
    (load-in-reg :rax index t)
    (fixnum-check :rax)
    (load-in-reg :r9 string t)
    (load-in-reg :r8 value t)
    (emit `(sys.lap-x86:mov64 :rdx :rax)
	  `(sys.lap-x86:sar64 :rdx 3)
	  `(sys.lap-x86:mov8 :cl :r9l)
	  `(sys.lap-x86:and8 :cl #b1111)
	  `(sys.lap-x86:cmp8 :cl ,sys.int::+tag-array-like+)
	  `(sys.lap-x86:jne ,type-error-label)
	  ;; Ensure that it is a simple-string.
	  `(sys.lap-x86:mov64 :rcx (:simple-array-header :r9))
	  `(sys.lap-x86:cmp8 :cl ,(ash sys.int::+array-type-base-char+ 1))
	  `(sys.lap-x86:je ,base-string-label)
	  `(sys.lap-x86:cmp8 :cl ,(ash sys.int::+array-type-character+ 1))
	  `(sys.lap-x86:jne ,type-error-label)
	  ;; simple-string (not simple-base-string).
	  `(sys.lap-x86:shr64 :rcx 8)
	  `(sys.lap-x86:cmp64 :rdx :rcx)
	  `(sys.lap-x86:jae ,bound-error-label)
          `(sys.lap-x86:mov8 :cl :r8l)
          `(sys.lap-x86:and8 :cl #b1111)
          `(sys.lap-x86:cmp8 :cl ,sys.int::+tag-character+)
          `(sys.lap-x86:jne ,char-type-error-label)
          `(sys.lap-x86:mov32 :eax :r8d)
          `(sys.lap-x86:shr32 :eax 4)
	  `(sys.lap-x86:mov32 (:r9 1 (:rdx 4)) :eax)
	  `(sys.lap-x86:jmp ,out-label)
	  ;; simple-base-string.
	  base-string-label
	  `(sys.lap-x86:shr64 :rcx 8)
	  `(sys.lap-x86:cmp64 :rdx :rcx)
	  `(sys.lap-x86:jae ,bound-error-label)
	  `(sys.lap-x86:xor32 :eax :eax)
          `(sys.lap-x86:mov8 :cl :r8l)
          `(sys.lap-x86:and8 :cl #b1111)
          `(sys.lap-x86:cmp8 :cl ,sys.int::+tag-character+)
          `(sys.lap-x86:jne ,base-char-type-error-label)
          `(sys.lap-x86:mov32 :eax :r8d)
          `(sys.lap-x86:shr32 :eax 4)
          `(sys.lap-x86:cmp32 :eax 256)
          `(sys.lap-x86:jae ,base-char-type-error-label)
	  `(sys.lap-x86:mov8 (:r9 1 :rdx) :al)
	  out-label)
    *r8-value*))

(define-tag-type-predicate symbolp sys.int::+tag-symbol+)
(define-reader symbol-name symbol sys.int::+tag-symbol+ :symbol-name)
(define-accessor symbol-package symbol sys.int::+tag-symbol+ :symbol-package)

(defbuiltin symbol-value (symbol) ()
  (let ((unbound-error-label (gensym))
	(type-error-label (gensym))
        (no-tls-slot (gensym))
        (test-bound (gensym)))
    (emit-trailer (unbound-error-label)
      (load-constant :r13 'sys.int::raise-unbound-error)
      (emit `(sys.lap-x86:mov64 :r8 :r9)
	    `(sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 1))
	    `(sys.lap-x86:call (:symbol-function :r13))
	    `(sys.lap-x86:ud2)))
    (emit-trailer (type-error-label)
      (raise-type-error :r9 'symbol))
    (load-in-reg :r9 symbol t)
    (smash-r8)
    (emit `(sys.lap-x86:mov8 :al :r9l)
	  `(sys.lap-x86:and8 :al #b1111)
	  `(sys.lap-x86:cmp8 :al ,sys.int::+tag-symbol+)
	  `(sys.lap-x86:jne ,type-error-label)
          ;; Extract the TLS offset.
          `(sys.lap-x86:mov32 :eax (:symbol-flags :r9))
          `(sys.lap-x86:shr32 :eax ,+tls-offset-shift+)
          `(sys.lap-x86:and32 :eax #xFFFF)
          `(sys.lap-x86:jz ,no-tls-slot)
          ;; Read from the TLS slot.
          `(sys.lap-x86:gs)
          `(sys.lap-x86:mov64 :r8 ((:rax 8) ,+tls-base-offset+))
          ;; Check if the TLS slot holds a value.
          `(sys.lap-x86:cmp64 :r8 -2)
          `(sys.lap-x86:jne ,test-bound)
          no-tls-slot
	  `(sys.lap-x86:mov64 :r8 (:symbol-value :r9))
          test-bound
	  `(sys.lap-x86:cmp64 :r8 ,sys.int::+tag-unbound-value+)
	  `(sys.lap-x86:je ,unbound-error-label))
    (setf *r8-value* (list (gensym)))))

(defbuiltin (setf symbol-value) (value symbol) ()
  (let ((type-error-label (gensym))
        (no-tls-slot (gensym))
        (out (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :r9 'symbol))
    (load-in-reg :r9 symbol t)
    (load-in-reg :r8 value t)
    (emit `(sys.lap-x86:mov8 :al :r9l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-symbol+)
          `(sys.lap-x86:jne ,type-error-label)
          ;; Extract the TLS offset.
          `(sys.lap-x86:mov32 :eax (:symbol-flags :r9))
          `(sys.lap-x86:shr32 :eax ,+tls-offset-shift+)
          `(sys.lap-x86:and32 :eax #xFFFF)
          `(sys.lap-x86:jz ,no-tls-slot)
          ;; Check if the TLS slot holds a value.
          `(sys.lap-x86:gs)
          `(sys.lap-x86:cmp64 ((:rax 8) ,+tls-base-offset+) -2)
          `(sys.lap-x86:je ,no-tls-slot)
          `(sys.lap-x86:gs)
          `(sys.lap-x86:mov64 ((:rax 8) ,+tls-base-offset+) :r8)
          `(sys.lap-x86:jmp ,out)
          no-tls-slot
          `(sys.lap-x86:mov64 (:symbol-value :r9) :r8)
          out)
    *r8-value*))

(defbuiltin symbol-function (symbol) ()
  (let ((type-error-label (gensym))
	(undefined-function-error-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :r8 'symbol))
    (emit-trailer (undefined-function-error-label)
      (load-constant :r13 'sys.int::raise-undefined-function)
      (emit `(sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 1))
            `(sys.lap-x86:call (:symbol-function :r13))
            `(sys.lap-x86:ud2)))
    (load-in-reg :r8 symbol t)
    (smash-r8)
    (emit `(sys.lap-x86:mov8 :al :r8l)
	  `(sys.lap-x86:and8 :al #b1111)
	  `(sys.lap-x86:cmp8 :al ,sys.int::+tag-symbol+)
	  `(sys.lap-x86:jne ,type-error-label)
          `(sys.lap-x86:cmp64 (:symbol-function :r8) undefined-function)
	  `(sys.lap-x86:je ,undefined-function-error-label)
          `(sys.lap-x86:mov64 :r8 (:symbol-function :r8)))
    (setf *r8-value* (list (gensym)))))

(defbuiltin (setf symbol-function) (value symbol) ()
  (let ((symbol-type-error-label (gensym))
	(function-type-error-label (gensym)))
    (emit-trailer (symbol-type-error-label)
      (raise-type-error :r9 'symbol))
    (emit-trailer (function-type-error-label)
      (raise-type-error :r8 'function))
    (load-in-reg :r9 symbol t)
    (load-in-r8 value t)
    (emit `(sys.lap-x86:mov8 :al :r9l)
	  `(sys.lap-x86:and8 :al #b1111)
	  `(sys.lap-x86:cmp8 :al ,sys.int::+tag-symbol+)
	  `(sys.lap-x86:jne ,symbol-type-error-label)
	  `(sys.lap-x86:mov8 :al :r8l)
	  `(sys.lap-x86:and8 :al #b1111)
	  `(sys.lap-x86:cmp8 :al ,sys.int::+tag-function+)
	  `(sys.lap-x86:jne ,function-type-error-label)
	  `(sys.lap-x86:mov64 (:symbol-function :r9) :r8))
    *r8-value*))

;; TODO type checking? ensure value is a plist?
(define-accessor symbol-plist symbol sys.int::+tag-symbol+ :symbol-plist)

;; TODO: type checking, value should be a fixnum.
(define-accessor sys.int::%symbol-flags symbol sys.int::+tag-symbol+ :symbol-flags)

;;; TODO: should just test the tag bits.
(defbuiltin boundp (symbol) ()
  (let ((type-error-label (gensym))
        (no-tls-slot (gensym))
        (out (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :r8 'symbol))
    (load-in-reg :r8 symbol t)
    (emit `(sys.lap-x86:mov8 :al :r8l)
	  `(sys.lap-x86:and8 :al #b1111)
	  `(sys.lap-x86:cmp8 :al ,sys.int::+tag-symbol+)
	  `(sys.lap-x86:jne ,type-error-label)
          ;; Extract the TLS offset.
          `(sys.lap-x86:mov32 :eax (:symbol-flags :r8))
          `(sys.lap-x86:shr32 :eax ,+tls-offset-shift+)
          `(sys.lap-x86:and32 :eax #xFFFF)
          `(sys.lap-x86:jz ,no-tls-slot)
          ;; Check if the TLS slot holds a value.
          `(sys.lap-x86:gs)
          `(sys.lap-x86:cmp64 ((:rax 8) ,+tls-base-offset+) -2)
          `(sys.lap-x86:je ,no-tls-slot)
          `(sys.lap-x86:gs)
          `(sys.lap-x86:cmp64 ((:rax 8) ,+tls-base-offset+) ,sys.int::+tag-unbound-value+)
          `(sys.lap-x86:jmp ,out)
          no-tls-slot
	  `(sys.lap-x86:cmp64 (:symbol-value :r8) ,sys.int::+tag-unbound-value+)
          out)
    (predicate-result :ne)))

(defbuiltin makunbound (symbol) ()
  (let ((type-error-label (gensym))
        (no-tls-slot (gensym))
        (out (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :r8 'symbol))
    (load-in-reg :r8 symbol t)
    (emit `(sys.lap-x86:mov8 :al :r8l)
	  `(sys.lap-x86:and8 :al #b1111)
	  `(sys.lap-x86:cmp8 :al ,sys.int::+tag-symbol+)
	  `(sys.lap-x86:jne ,type-error-label)
          ;; Extract the TLS offset.
          `(sys.lap-x86:mov32 :eax (:symbol-flags :r8))
          `(sys.lap-x86:shr32 :eax ,+tls-offset-shift+)
          `(sys.lap-x86:and32 :eax #xFFFF)
          `(sys.lap-x86:jz ,no-tls-slot)
          ;; Check if the TLS slot holds a value.
          `(sys.lap-x86:gs)
          `(sys.lap-x86:cmp64 ((:rax 8) ,+tls-base-offset+) -2)
          `(sys.lap-x86:je ,no-tls-slot)
          `(sys.lap-x86:gs)
          `(sys.lap-x86:mov64 ((:rax 8) ,+tls-base-offset+) ,sys.int::+tag-unbound-value+)
          `(sys.lap-x86:jmp ,out)
          no-tls-slot
	  `(sys.lap-x86:mov64 (:symbol-value :r8) ,sys.int::+tag-unbound-value+)
          out)
    *r8-value*))

;;; FBOUNDP but just for symbols.
(defbuiltin sys.int::%fboundp (symbol) ()
  (let ((type-error-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :r8 'symbol))
    (load-in-reg :r8 symbol t)
    (emit `(sys.lap-x86:mov8 :al :r8l)
	  `(sys.lap-x86:and8 :al #b1111)
	  `(sys.lap-x86:cmp8 :al ,sys.int::+tag-symbol+)
	  `(sys.lap-x86:jne ,type-error-label)
	  `(sys.lap-x86:cmp64 (:symbol-function :r8) undefined-function))
    (predicate-result :ne)))

;;; FMAKUNBOUND but just for symbols.
(defbuiltin sys.int::%fmakunbound (symbol) ()
  (let ((type-error-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :r8 'symbol))
    (load-in-reg :r8 symbol t)
    (emit `(sys.lap-x86:mov8 :al :r8l)
	  `(sys.lap-x86:and8 :al #b1111)
	  `(sys.lap-x86:cmp8 :al ,sys.int::+tag-symbol+)
	  `(sys.lap-x86:jne ,type-error-label)
	  `(sys.lap-x86:mov64 (:symbol-function :r8) undefined-function))
    *r8-value*))

(define-tag-type-predicate consp sys.int::+tag-cons+)

(defbuiltin car (list) ()
  (let ((type-error-label (gensym))
        (out-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :r8 'list))
    (load-in-reg :r8 list t)
    (smash-r8)
    (emit `(sys.lap-x86:cmp64 :r8 nil)
          `(sys.lap-x86:je ,out-label)
          `(sys.lap-x86:mov8 :al :r8l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-cons+)
          `(sys.lap-x86:jne ,type-error-label)
          `(sys.lap-x86:mov64 :r8 (:car :r8))
          out-label)
    (setf *r8-value* (list (gensym)))))

(defbuiltin cdr (list) ()
  (let ((type-error-label (gensym))
        (out-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :r8 'list))
    (load-in-reg :r8 list t)
    (smash-r8)
    (emit `(sys.lap-x86:cmp64 :r8 nil)
          `(sys.lap-x86:je ,out-label)
          `(sys.lap-x86:mov8 :al :r8l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-cons+)
          `(sys.lap-x86:jne ,type-error-label)
          `(sys.lap-x86:mov64 :r8 (:cdr :r8))
          out-label)
    (setf *r8-value* (list (gensym)))))

(define-writer (setf car) cons sys.int::+tag-cons+ :car)
(define-writer (setf cdr) cons sys.int::+tag-cons+ :cdr)

(define-tag-type-predicate sys.int::%array-header-p sys.int::+tag-array-header+)
(define-accessor sys.int::%array-header-dimensions
    sys.int::%array-header sys.int::+tag-array-header+
    :array-header-dimensions)
(define-accessor sys.int::%array-header-fill-pointer
    sys.int::%array-header sys.int::+tag-array-header+
    :array-header-fill-pointer)
(define-accessor sys.int::%array-header-info
    sys.int::%array-header sys.int::+tag-array-header+
    :array-header-info)
(define-accessor sys.int::%array-header-storage
    sys.int::%array-header sys.int::+tag-array-header+
    :array-header-storage)

(defbuiltin null (object) ()
  (load-in-reg :r8 object t)
  (emit `(sys.lap-x86:cmp64 :r8 nil))
  (predicate-result :e))

(defbuiltin not (object) ()
  (load-in-reg :r8 object t)
  (emit `(sys.lap-x86:cmp64 :r8 nil))
  (predicate-result :e))

(defbuiltin eq (x y) ()
  (load-in-reg :r9 y t)
  (load-in-reg :r8 x t)
  (emit `(sys.lap-x86:cmp64 :r8 :r9))
  (predicate-result :e))

(defbuiltin eql (x y) ()
  (load-in-reg :r9 y t)
  (load-in-reg :r8 x t)
  (emit `(sys.lap-x86:cmp64 :r8 :r9))
  (predicate-result :e))

(defbuiltin system:io-port/8 (port) ()
  (smash-r8)
  (emit `(sys.lap-x86:xor32 :eax :eax))
  (cond ((and (consp port)
              (eql (first port) 'quote)
              (<= 0 (second port) 255))
         (smash-r8)
         (setf *load-list* (delete port *load-list*))
         (emit `(sys.lap-x86:in8 ,(second port))))
        (t (let ((type-error-label (gensym)))
             (emit-trailer (type-error-label)
               (raise-type-error :r8 '(unsigned-byte 16)))
             (load-in-r8 port t)
             (emit `(sys.lap-x86:test64 :r8 #b111)
                   `(sys.lap-x86:jnz ,type-error-label)
                   `(sys.lap-x86:cmp64 :r8 ,(* #x10000 8))
                   `(sys.lap-x86:jae ,type-error-label)
                   `(sys.lap-x86:mov64 :rdx :r8)
                   ;; Convert to a raw integer.
                   `(sys.lap-x86:sar32 :edx 3)
                   `(sys.lap-x86:in8 :dx)))))
  (emit `(sys.lap-x86:shl32 :eax 3)
        `(sys.lap-x86:mov32 :r8d :eax))
  (setf *r8-value* (list (gensym))))

(defbuiltin (setf system:io-port/8) (value port) ()
  (load-in-r8 value t)
  (let ((value-type-error-label (gensym)))
    (emit-trailer (value-type-error-label)
      (raise-type-error :r8 '(unsigned-byte 8)))
    (emit `(sys.lap-x86:test64 :r8 #b111)
          `(sys.lap-x86:jnz ,value-type-error-label)
          `(sys.lap-x86:cmp64 :r8 ,(* #x100 8))
          `(sys.lap-x86:jae ,value-type-error-label)
          `(sys.lap-x86:mov64 :rax :r8)
          `(sys.lap-x86:sar32 :eax 3))
    (cond ((and (consp port)
                (eql (first port) 'quote)
                (<= 0 (second port) 255))
           (smash-r8)
           (setf *load-list* (delete port *load-list*))
           (emit `(sys.lap-x86:out8 ,(second port))))
          (t (let ((type-error-label (gensym)))
               (emit-trailer (type-error-label)
                             (raise-type-error :r9 '(unsigned-byte 16)))
               (load-in-reg :r9 port t)
               (emit `(sys.lap-x86:test64 :r9 #b111)
                     `(sys.lap-x86:jnz ,type-error-label)
                     `(sys.lap-x86:cmp64 :r9 ,(* #x10000 8))
                     `(sys.lap-x86:jae ,type-error-label)
                     `(sys.lap-x86:mov64 :rdx :r9)
                     ;; Convert to a raw integer.
                     `(sys.lap-x86:sar32 :edx 3)
                     `(sys.lap-x86:out8 :dx)))))
    value))

(defbuiltin system:io-port/16 (port) ()
  (smash-r8)
  (emit `(sys.lap-x86:xor32 :eax :eax))
  (cond ((and (consp port)
              (eql (first port) 'quote)
              (<= 0 (second port) 255))
         (smash-r8)
         (setf *load-list* (delete port *load-list*))
         (emit `(sys.lap-x86:in16 ,(second port))))
        (t (let ((type-error-label (gensym)))
             (emit-trailer (type-error-label)
               (raise-type-error :r8 '(unsigned-byte 16)))
             (load-in-r8 port t)
             (emit `(sys.lap-x86:test64 :r8 #b111)
                   `(sys.lap-x86:jnz ,type-error-label)
                   `(sys.lap-x86:cmp64 :r8 ,(* #x10000 8))
                   `(sys.lap-x86:jae ,type-error-label)
                   `(sys.lap-x86:mov64 :rdx :r8)
                   ;; Convert to a raw integer.
                   `(sys.lap-x86:sar32 :edx 3)
                   `(sys.lap-x86:in16 :dx)))))
  (emit `(sys.lap-x86:shl32 :eax 3)
        `(sys.lap-x86:mov32 :r8d :eax))
  (setf *r8-value* (list (gensym))))

(defbuiltin (setf system:io-port/16) (value port) ()
  (load-in-r8 value t)
  (let ((value-type-error-label (gensym)))
    (emit-trailer (value-type-error-label)
      (raise-type-error :r8 '(unsigned-byte 16)))
    (emit `(sys.lap-x86:test64 :r8 #b111)
          `(sys.lap-x86:jnz ,value-type-error-label)
          `(sys.lap-x86:cmp64 :r8 ,(* #x10000 8))
          `(sys.lap-x86:jae ,value-type-error-label)
          `(sys.lap-x86:mov64 :rax :r8)
          `(sys.lap-x86:sar32 :eax 3))
    (cond ((and (consp port)
                (eql (first port) 'quote)
                (<= 0 (second port) 255))
           (smash-r8)
           (setf *load-list* (delete port *load-list*))
           (emit `(sys.lap-x86:out16 ,(second port))))
          (t (let ((type-error-label (gensym)))
               (emit-trailer (type-error-label)
                             (raise-type-error :r9 '(unsigned-byte 16)))
               (load-in-reg :r9 port t)
               (emit `(sys.lap-x86:test64 :r9 #b111)
                     `(sys.lap-x86:jnz ,type-error-label)
                     `(sys.lap-x86:cmp64 :r9 ,(* #x10000 8))
                     `(sys.lap-x86:jae ,type-error-label)
                     `(sys.lap-x86:mov64 :rdx :r9)
                     ;; Convert to a raw integer.
                     `(sys.lap-x86:sar32 :edx 3)
                     `(sys.lap-x86:out16 :dx)))))
    value))

(defbuiltin system:io-port/32 (port) ()
  (smash-r8)
  (emit `(sys.lap-x86:xor32 :eax :eax))
  (cond ((and (consp port)
              (eql (first port) 'quote)
              (<= 0 (second port) 255))
         (smash-r8)
         (setf *load-list* (delete port *load-list*))
         (emit `(sys.lap-x86:in32 ,(second port))))
        (t (let ((type-error-label (gensym)))
             (emit-trailer (type-error-label)
               (raise-type-error :r8 '(unsigned-byte 16)))
             (load-in-r8 port t)
             (emit `(sys.lap-x86:test64 :r8 #b111)
                   `(sys.lap-x86:jnz ,type-error-label)
                   `(sys.lap-x86:cmp64 :r8 ,(* #x10000 8))
                   `(sys.lap-x86:jae ,type-error-label)
                   `(sys.lap-x86:mov64 :rdx :r8)
                   ;; Convert to a raw integer.
                   `(sys.lap-x86:sar32 :edx 3)
                   `(sys.lap-x86:in32 :dx)))))
  (emit `(sys.lap-x86:shl64 :rax 3)
        `(sys.lap-x86:mov64 :r8 :rax))
  (setf *r8-value* (list (gensym))))

(defbuiltin (setf system:io-port/32) (value port) ()
  (load-in-r8 value t)
  (let ((value-type-error-label (gensym)))
    (emit-trailer (value-type-error-label)
      (raise-type-error :r8 '(unsigned-byte 8)))
    (emit `(sys.lap-x86:test64 :r8 #b111)
          `(sys.lap-x86:jnz ,value-type-error-label)
          `(sys.lap-x86:mov64 :rax :r8)
          `(sys.lap-x86:sar64 :rax 3)
          `(sys.lap-x86:mov64 :rdx :rax)
          `(sys.lap-x86:sar64 :rdx 32)
          `(sys.lap-x86:jnz ,value-type-error-label))
    (cond ((and (consp port)
                (eql (first port) 'quote)
                (<= 0 (second port) 255))
           (smash-r8)
           (setf *load-list* (delete port *load-list*))
           (emit `(sys.lap-x86:out32 ,(second port))))
          (t (let ((type-error-label (gensym)))
               (emit-trailer (type-error-label)
                             (raise-type-error :r9 '(unsigned-byte 16)))
               (load-in-reg :r9 port t)
               (emit `(sys.lap-x86:test64 :r9 #b111)
                     `(sys.lap-x86:jnz ,type-error-label)
                     `(sys.lap-x86:cmp64 :r9 ,(* #x10000 8))
                     `(sys.lap-x86:jae ,type-error-label)
                     `(sys.lap-x86:mov64 :rdx :r9)
                     ;; Convert to a raw integer.
                     `(sys.lap-x86:sar32 :edx 3)
                     `(sys.lap-x86:out32 :dx)))))
    value))

(defbuiltin simple-vector-p (object) ()
  (let ((out (gensym)))
    (load-in-r8 object t)
    (emit `(sys.lap-x86:mov8 :al :r8l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-array-like+)
          `(sys.lap-x86:jne ,out)
          `(sys.lap-x86:mov64 :rax (:simple-array-header :r8))
          `(sys.lap-x86:test8 :al :al)
          ;; Subtle. OUT can be reached through either the tag check
          ;; or through the array type check. Both checks clear ZF when
          ;; they fail.
          out)
    (predicate-result :z)))

(defbuiltin svref (simple-vector index) ()
  (let ((type-error-label (gensym))
        (bounds-error-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :r8 'simple-vector))
    (emit-trailer (bounds-error-label)
      (load-constant :r13 'sys.int::raise-bounds-error)
      (emit `(sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 2))
            `(sys.lap-x86:call (:symbol-function :r13))
            `(sys.lap-x86:ud2)))
    (load-in-reg :r8 simple-vector t)
    (smash-r8)
    (load-in-reg :r9 index t)
    (fixnum-check :r9)
    (emit `(sys.lap-x86:mov8 :al :r8l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-array-like+)
          `(sys.lap-x86:jne ,type-error-label)
          ;; Load header word.
          `(sys.lap-x86:mov64 :rax (:simple-array-header :r8))
          ;; Check array type.
          `(sys.lap-x86:test8 :al :al)
          `(sys.lap-x86:jnz ,type-error-label)
          ;; Check bounds.
          `(sys.lap-x86:mov64 :rcx :r9)
          `(sys.lap-x86:shr64 :rcx 3)
          `(sys.lap-x86:shr64 :rax 8)
          `(sys.lap-x86:cmp64 :rcx :rax)
          `(sys.lap-x86:jae ,bounds-error-label)
          ;; Load!
          `(sys.lap-x86:mov64 :r8 (:r8 1 (:rcx 8))))
    (setf *r8-value* (list (gensym)))))

(defbuiltin (setf svref) (value simple-vector index) ()
  (let ((type-error-label (gensym))
        (bounds-error-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :r9 'simple-vector))
    (emit-trailer (bounds-error-label)
      (load-constant :r13 'sys.int::raise-bounds-error)
      (emit `(sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 2))
            `(sys.lap-x86:call (:symbol-function :r13))
            `(sys.lap-x86:ud2)))
    (load-in-reg :r8 value t)
    (load-in-reg :r9 simple-vector t)
    (load-in-reg :r10 index t)
    (fixnum-check :r10)
    (emit `(sys.lap-x86:mov8 :al :r9l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-array-like+)
          `(sys.lap-x86:jne ,type-error-label)
          ;; Load header word.
          `(sys.lap-x86:mov64 :rax (:simple-array-header :r9))
          ;; Check array type.
          `(sys.lap-x86:test8 :al :al)
          `(sys.lap-x86:jnz ,type-error-label)
          ;; Check bounds.
          `(sys.lap-x86:mov64 :rcx :r10)
          `(sys.lap-x86:shr64 :rcx 3)
          `(sys.lap-x86:shr64 :rax 8)
          `(sys.lap-x86:cmp64 :rcx :rax)
          `(sys.lap-x86:jae ,bounds-error-label)
          ;; Store!
          `(sys.lap-x86:mov64 (:r9 1 (:rcx 8)) :r8))
    (setf *r8-value* (list (gensym)))))

(define-tag-type-predicate characterp sys.int::+tag-character+)

(defbuiltin system.internals::read-frame-pointer () ()
  (smash-r8)
  (emit `(sys.lap-x86:mov64 :rax :cfp)
        `(sys.lap-x86:shl64 :rax 3)
        `(sys.lap-x86:mov64 :r8 :rax))
  (setf *r8-value* (list (gensym))))

(defbuiltin system.internals::structure-object-p (object) ()
  (let ((out (gensym)))
    (load-in-reg :r9 object t)
    (smash-r8)
    ;; Check tag.
    (emit `(sys.lap-x86:mov64 :r8 nil)
          `(sys.lap-x86:mov8 :al :r9l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-array-like+)
          `(sys.lap-x86:jne ,out)
          `(sys.lap-x86:mov8 :al (:simple-array-header :r9))
          `(sys.lap-x86:cmp8 :al ,(ash sys.int::+array-type-struct+ 1))
          `(sys.lap-x86:mov64 :r9 t)
          `(sys.lap-x86:cmov64e :r8 :r9)
          out)
    (setf *r8-value* (list (gensym)))))

(defbuiltin system.internals::%struct-slot (object slot) ()
  (let ((type-error-label (gensym))
        (bounds-error-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :r8 'structure-object))
    (emit-trailer (bounds-error-label)
      (load-constant :r13 'sys.int::raise-bounds-error)
      (emit `(sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 2))
            `(sys.lap-x86:call (:symbol-function :r13))
            `(sys.lap-x86:ud2)))
    (load-in-reg :r9 slot t)
    (fixnum-check :r9)
    (load-in-reg :r8 object t)
    (smash-r8)
    (emit `(sys.lap-x86:mov8 :al :r8l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-array-like+)
          `(sys.lap-x86:jne ,type-error-label)
          `(sys.lap-x86:mov64 :rax (:simple-array-header :r8))
          `(sys.lap-x86:cmp8 :al ,(ash sys.int::+array-type-struct+ 1))
          `(sys.lap-x86:jne ,type-error-label)
          ;; Convert size and slot number to integers.
          `(sys.lap-x86:shr64 :rax 8)
          `(sys.lap-x86:mov64 :rcx :r9)
          `(sys.lap-x86:shr64 :rcx 3)
          ;; Check bounds.
          `(sys.lap-x86:cmp64 :rcx :rax)
          `(sys.lap-x86:jae ,bounds-error-label)
          ;; Load.
          `(sys.lap-x86:mov64 :r8 (:r8 1 (:rcx 8))))
    (setf *r8-value* (list (gensym)))))

(defbuiltin (setf system.internals::%struct-slot) (value object slot) ()
  (let ((type-error-label (gensym))
        (bounds-error-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :r9 'structure-object))
    (emit-trailer (bounds-error-label)
      (load-constant :r13 'sys.int::raise-bounds-error)
      (emit `(sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 2))
            `(sys.lap-x86:call (:symbol-function :r13))
            `(sys.lap-x86:ud2)))
    (load-in-reg :r10 slot t)
    (fixnum-check :r10)
    (load-in-reg :r9 object t)
    (load-in-reg :r8 value t)
    (emit `(sys.lap-x86:mov8 :al :r9l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-array-like+)
          `(sys.lap-x86:jne ,type-error-label)
          `(sys.lap-x86:mov64 :rax (:simple-array-header :r9))
          `(sys.lap-x86:cmp8 :al ,(ash sys.int::+array-type-struct+ 1))
          `(sys.lap-x86:jne ,type-error-label)
          ;; Convert size and slot number to integers.
          `(sys.lap-x86:shr64 :rax 8)
          `(sys.lap-x86:mov64 :rcx :r10)
          `(sys.lap-x86:shr64 :rcx 3)
          ;; Check bounds.
          `(sys.lap-x86:cmp64 :rcx :rax)
          `(sys.lap-x86:jae ,bounds-error-label)
          ;; Store.
          `(sys.lap-x86:mov64 (:r9 1 (:rcx 8)) :r8))
    *r8-value*))

(defbuiltin char-code (char) ()
  (let ((type-error-label (gensym)))
    (emit-trailer (type-error-label)
		  (raise-type-error :r8 'character))
    (load-in-r8 char t)
    (smash-r8)
    (emit `(sys.lap-x86:mov8 :al :r8l)
	  `(sys.lap-x86:and8 :al #b1111)
	  `(sys.lap-x86:cmp8 :al ,sys.int::+tag-character+)
	  `(sys.lap-x86:jne ,type-error-label)
	  ;; Mask away the non-code bits.
	  `(sys.lap-x86:and32 :r8d #x01fffff0)
	  ;; Shift to fixnum.
	  `(sys.lap-x86:shr32 :r8d 1))
    (setf *r8-value* (list (gensym)))))

(defbuiltin system:char-bits (character) ()
  (let ((type-error-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :r8 'character))
    (load-in-r8 character t)
    (smash-r8)
    (emit `(sys.lap-x86:mov8 :al :r8l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-character+)
          `(sys.lap-x86:jne ,type-error-label)
          `(sys.lap-x86:and32 :r8d #x1e000000)
          `(sys.lap-x86:shr32 :r8d 22))
    (setf *r8-value* (list (gensym)))))

(defbuiltin char-int (char) ()
  (let ((type-error-label (gensym)))
    (emit-trailer (type-error-label)
		  (raise-type-error :r8 'character))
    (load-in-r8 char t)
    (smash-r8)
    (emit `(sys.lap-x86:mov8 :al :r8l)
	  `(sys.lap-x86:and8 :al #b1111)
	  `(sys.lap-x86:cmp8 :al ,sys.int::+tag-character+)
	  `(sys.lap-x86:jne ,type-error-label)
	  ;; Mask away the tag bits.
	  `(sys.lap-x86:and32 :r8d -16)
	  ;; Shift to fixnum.
	  `(sys.lap-x86:shr32 :r8d 1))
    (setf *r8-value* (list (gensym)))))

(defbuiltin system:fixnump (object) ()
  (load-in-reg :r8 object t)
  (emit `(sys.lap-x86:test8 :r8l #b111))
  (predicate-result :z))

(defbuiltin sys.int::%%assemble-value (address tag) ()
  (load-in-reg :rax tag t)
  (load-in-reg :r8 address t)
  (smash-r8)
  (emit `(sys.lap-x86:shr32 :eax 3)
        `(sys.lap-x86:shr64 :r8 3)
        `(sys.lap-x86:or64 :r8 :rax))
  (setf *r8-value* (list (gensym))))

(defbuiltin sys.int::%pointer-field (value) ()
  (load-in-reg :r8 value t)
  (smash-r8)
  (emit `(sys.lap-x86:and64 :r8 -16)
        `(sys.lap-x86:shr64 :r8 1))
  (setf *r8-value* (list (gensym))))

(defbuiltin sys.int::%tag-field (value) ()
  (load-in-reg :r8 value t)
  (smash-r8)
  (emit `(sys.lap-x86:shl64 :r8 3)
        `(sys.lap-x86:and64 :r8 #b1111000))
  (setf *r8-value* (list (gensym))))

(defbuiltin sys.int::lisp-object-address (value) ()
  (load-in-reg :r8 value t)
  (smash-r8)
  ;; Convert to fixnum.
  (emit `(sys.lap-x86:shl64 :r8 3))
  (setf *r8-value* (list (gensym))))

;;; Apply does not generate a function.
(defbuiltin apply (function arguments) (nil)
  (let ((type-error-label (gensym))
        (fn-type-error-label (gensym))
        (loop-test (gensym))
        (loop-head (gensym))
        (rev-loop-test (gensym))
        (rev-loop-head (gensym))
        (arg-done (gensym))
        (function-label (gensym))
        (out-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :r8 'list))
    (emit-trailer (fn-type-error-label)
      (raise-type-error :r13 '(or function symbol)))
    (load-in-reg :r13 function t)
    (load-in-reg :r8 arguments t)
    (smash-r8)
    ;; Unpack the argument list on the stack in reverse and count
    ;; the number of arguments.
    (emit `(sys.lap-x86:xor32 :ecx :ecx)
          `(sys.lap-x86:jmp ,loop-test)
          loop-head
          `(sys.lap-x86:mov8 :al :r8l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-cons+)
          `(sys.lap-x86:jne ,type-error-label)
          `(sys.lap-x86:mov64 (:lsp -8) nil)
          `(sys.lap-x86:sub64 :lsp 8)
          `(sys.lap-x86:mov64 :r9 (:car :r8))
          `(sys.lap-x86:mov64 (:lsp) :r9)
          `(sys.lap-x86:mov64 :r8 (:cdr :r8))
          `(sys.lap-x86:add64 :rcx 8)
          loop-test
          `(sys.lap-x86:cmp64 :r8 nil)
          `(sys.lap-x86:jne ,loop-head)
          ;; Arguments are now on the stack, in reverse and RCX holds the list length.
          ;; Reverse them.
          `(sys.lap-x86:lea64 :rax (:rcx -8))
          `(sys.lap-x86:xor32 :edx :edx)
          `(sys.lap-x86:jmp ,rev-loop-test)
          rev-loop-head
          `(sys.lap-x86:mov64 :r9 (:lsp :rax))
          `(sys.lap-x86:mov64 :r10 (:lsp :rdx))
          `(sys.lap-x86:mov64 (:lsp :rax) :r10)
          `(sys.lap-x86:mov64 (:lsp :rdx) :r9)
          `(sys.lap-x86:add64 :rdx 8)
          `(sys.lap-x86:sub64 :rax 8)
          rev-loop-test
          `(sys.lap-x86:cmp64 :rax :rdx)
          `(sys.lap-x86:jg ,rev-loop-head)
          ;; Put arguments into registers.
          `(sys.lap-x86:test64 :rcx :rcx)
          `(sys.lap-x86:jz ,arg-done)
          `(sys.lap-x86:mov64 :r8 (:lsp))
          `(sys.lap-x86:add64 :lsp 8)
          `(sys.lap-x86:cmp64 :rcx ,(fixnum-to-raw 1))
          `(sys.lap-x86:je ,arg-done)
          `(sys.lap-x86:mov64 :r9 (:lsp))
          `(sys.lap-x86:add64 :lsp 8)
          `(sys.lap-x86:cmp64 :rcx ,(fixnum-to-raw 2))
          `(sys.lap-x86:je ,arg-done)
          `(sys.lap-x86:mov64 :r10 (:lsp))
          `(sys.lap-x86:add64 :lsp 8)
          `(sys.lap-x86:cmp64 :rcx ,(fixnum-to-raw 3))
          `(sys.lap-x86:je ,arg-done)
          `(sys.lap-x86:mov64 :r11 (:lsp))
          `(sys.lap-x86:add64 :lsp 8)
          `(sys.lap-x86:cmp64 :rcx ,(fixnum-to-raw 4))
          `(sys.lap-x86:je ,arg-done)
          `(sys.lap-x86:mov64 :r12 (:lsp))
          `(sys.lap-x86:add64 :lsp 8)
          arg-done
          ;; Finally, do the call.
          `(sys.lap-x86:mov8 :al :r13l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-function+)
          `(sys.lap-x86:je ,function-label)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-symbol+)
          `(sys.lap-x86:jne ,fn-type-error-label)
          `(sys.lap-x86:call (:symbol-function :r13))
          `(sys.lap-x86:jmp ,out-label)
          function-label
          `(sys.lap-x86:call :r13)
          out-label)
    (cond ((eql *for-value* :multiple)
           :multiple)
          (t (emit `(sys.lap-x86:mov64 :lsp :rbx))
             (setf *r8-value* (list (gensym)))))))

(define-tag-type-predicate sys.int::std-instance-p sys.int::+tag-std-instance+)
(define-accessor sys.int::std-instance-class
    sys.int::std-instance sys.int::+tag-std-instance+
    :std-instance-class)
(define-accessor sys.int::std-instance-slots
    sys.int::std-instance sys.int::+tag-std-instance+
    :std-instance-slots)

(define-tag-type-predicate functionp sys.int::+tag-function+)

(defbuiltin values-list (list) ()
  (let ((type-error-label (gensym))
        (nil-test (gensym))
        (loop-test (gensym))
        (loop-head (gensym))
        (rev-loop-test (gensym))
        (rev-loop-head (gensym))
        (arg-done (gensym))
        (out (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :r8 'list))
    (load-in-r8 list t)
    (smash-r8)
    (cond
      ((eql *for-value* :multiple)
       (emit `(sys.lap-x86:xor32 :ecx :ecx)
             ;; Save the stack pointer.
             `(sys.lap-x86:mov64 :rbx :lsp)
             `(sys.lap-x86:jmp ,loop-test)
             loop-head
             `(sys.lap-x86:mov8 :al :r8l)
             `(sys.lap-x86:and8 :al #b1111)
             `(sys.lap-x86:cmp8 :al ,sys.int::+tag-cons+)
             `(sys.lap-x86:jne ,type-error-label)
             `(sys.lap-x86:mov64 (:lsp -8) nil)
             `(sys.lap-x86:sub64 :lsp 8)
             `(sys.lap-x86:mov64 :r9 (:car :r8))
             `(sys.lap-x86:mov64 (:lsp) :r9)
             `(sys.lap-x86:mov64 :r8 (:cdr :r8))
             `(sys.lap-x86:add64 :rcx 8)
             loop-test
             `(sys.lap-x86:cmp64 :r8 nil)
             `(sys.lap-x86:jne ,loop-head)
             ;; Arguments are now on the stack, in reverse and RCX holds the list length.
             ;; Reverse them.
             `(sys.lap-x86:lea64 :rax (:rcx -8))
             `(sys.lap-x86:xor32 :edx :edx)
             `(sys.lap-x86:jmp ,rev-loop-test)
             rev-loop-head
             `(sys.lap-x86:mov64 :r9 (:lsp :rax))
             `(sys.lap-x86:mov64 :r10 (:lsp :rdx))
             `(sys.lap-x86:mov64 (:lsp :rax) :r10)
             `(sys.lap-x86:mov64 (:lsp :rdx) :r9)
             `(sys.lap-x86:add64 :rdx 8)
             `(sys.lap-x86:sub64 :rax 8)
             rev-loop-test
             `(sys.lap-x86:cmp64 :rax :rdx)
             `(sys.lap-x86:jg ,rev-loop-head)
             ;; Put arguments into registers.
             ;; R8 must always hold nil.
             `(sys.lap-x86:mov64 :r8 nil)
             `(sys.lap-x86:test64 :rcx :rcx)
             `(sys.lap-x86:jz ,arg-done)
             `(sys.lap-x86:mov64 :r8 (:lsp))
             `(sys.lap-x86:add64 :lsp 8)
             `(sys.lap-x86:cmp64 :rcx ,(fixnum-to-raw 1))
             `(sys.lap-x86:je ,arg-done)
             `(sys.lap-x86:mov64 :r9 (:lsp))
             `(sys.lap-x86:add64 :lsp 8)
             `(sys.lap-x86:cmp64 :rcx ,(fixnum-to-raw 2))
             `(sys.lap-x86:je ,arg-done)
             `(sys.lap-x86:mov64 :r10 (:lsp))
             `(sys.lap-x86:add64 :lsp 8)
             `(sys.lap-x86:cmp64 :rcx ,(fixnum-to-raw 3))
             `(sys.lap-x86:je ,arg-done)
             `(sys.lap-x86:mov64 :r11 (:lsp))
             `(sys.lap-x86:add64 :lsp 8)
             `(sys.lap-x86:cmp64 :rcx ,(fixnum-to-raw 4))
             `(sys.lap-x86:je ,arg-done)
             `(sys.lap-x86:mov64 :r12 (:lsp))
             `(sys.lap-x86:add64 :lsp 8)
             ;; Done, values are loaded in registers and on the stack.
             ;; RCX holds count, RBX holds the stack pointer.
             arg-done)
       :multiple)
      (t (emit `(sys.lap-x86:mov8 :al :r8l)
               `(sys.lap-x86:and8 :al #b1111)
               `(sys.lap-x86:cmp8 :al ,sys.int::+tag-cons+)
               `(sys.lap-x86:jne ,nil-test)
               `(sys.lap-x86:mov64 :r8 (:car :r8))
               `(sys.lap-x86:jne ,out)
               nil-test
               `(sys.lap-x86:cmp64 :r8 nil)
               `(sys.lap-x86:jne ,type-error-label)
               out)
         (setf *r8-value* (list (gensym)))))))

(defbuiltin sys.int::%stihlt () ()
  (emit `(sys.lap-x86:sti)
        `(sys.lap-x86:hlt))
  ''nil)

(defbuiltin sys.int::%sti () ()
  (emit `(sys.lap-x86:sti))
  ''nil)

(defbuiltin sys.int::%cli () ()
  (emit `(sys.lap-x86:cli))
  ''nil)

(defbuiltin sys.int::%hlt () ()
  (emit `(sys.lap-x86:hlt))
  ''nil)

(defbuiltin sys.int::%interrupt-state () ()
  (emit `(sys.lap-x86:pushf)
        `(sys.lap-x86:pop :rax)
        `(sys.lap-x86:test32 :eax #x200))
  (predicate-result :nz))

(defbuiltin sys.int::%cr3 () ()
  (emit `(sys.lap-x86:movcr :rax :cr3)
        `(sys.lap-x86:shl64 :rax 3)
        `(sys.lap-x86:mov64 :r8 :rax))
  (setf *r8-value* (list (gensym))))

(defbuiltin (setf sys.int::%cr3) (value) ()
  (load-in-r8 value t)
  (fixnum-check :r8)
  (emit `(sys.lap-x86:mov64 :rax :r8)
        `(sys.lap-x86:shr64 :rax 3)
        `(sys.lap-x86:movcr :cr3 :rax))
  value)

(defbuiltin sys.int::%%get-data-stack-pointer () ()
  (smash-r8)
  (emit `(sys.lap-x86:mov64 :r8 :lsp))
  (setf *r8-value* (list (gensym))))

(defbuiltin system.internals::bignump (object) ()
  (let ((out (gensym)))
    (load-in-reg :r8 object t)
    ;; Check tag.
    (emit `(sys.lap-x86:mov8 :al :r8l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-array-like+)
          `(sys.lap-x86:jne ,out)
          `(sys.lap-x86:mov8 :al (:simple-array-header :r8))
          `(sys.lap-x86:cmp8 :al ,(ash sys.int::+array-type-bignum+ 1))
          out)
    (predicate-result :e)))
