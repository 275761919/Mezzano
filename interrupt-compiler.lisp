(defpackage #:sys.intc
  (:use #:cl #:sys.lap-x86)
  (:export define-interrupt-handler make-interrupt-handler))

(in-package #:sys.intc)

(defstruct interrupt-handler-template
  name
  arguments
  variables
  body)

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defun parse-interrupt-handler-lambda-list (lambda-list)
    (let ((auxp (position '&aux lambda-list)))
      (if auxp
          (values (subseq lambda-list 0 auxp)
                  (subseq lambda-list (1+ auxp)))
          (values lambda-list nil)))))

(defmacro define-interrupt-handler (name lambda-list &body body)
  (multiple-value-bind (arguments variables)
      (parse-interrupt-handler-lambda-list lambda-list)
    `(progn (setf (get ',name 'interrupt-handler)
                  (make-interrupt-handler-template
                   :name ',name
                   :arguments ',arguments
                   :variables ',variables
                   :body ',body))
            ',name)))

(defstruct var
  name
  constant-p
  value
  undefined-p
  stack-slot
  type)

(defvar *variable-info*)
(defvar *stack-depth*)
(defvar *max-stack-depth*)
(defvar *code-tail*)

(defparameter *form-compilers* (make-hash-table))
(defparameter *setf-form-compilers* (make-hash-table))

(defmacro define-form (name lambda-list (for-value-p &optional expected-type) &body body)
  (unless expected-type (setf expected-type (gensym)))
  (cond ((symbolp name)
         (let ((whole (gensym)))
           `(setf (gethash ',name *form-compilers*)
                  (lambda (,whole ,for-value-p ,expected-type)
                    (declare (ignorable ,whole ,for-value-p ,expected-type)
                             (system:lambda-name (icomp-form ,name)))
                    (destructuring-bind ,lambda-list (cdr ,whole) ,@body)))))
        ((and (listp name)
              (= (length name) 2)
              (eql (first name) 'setf))
         (let ((whole (gensym)))
           `(setf (gethash ',(second name) *setf-form-compilers*)
                  (lambda (,whole ,for-value-p ,expected-type)
                    (declare (ignorable ,whole ,for-value-p ,expected-type)
                             (system:lambda-name (icomp-form ,name)))
                    (destructuring-bind ,lambda-list (cdr ,whole) ,@body)))))
        (t (error "Invalid name ~S." name))))

(defmacro with-stack-slots ((&rest slot-names) &body body)
  `(let (,@(let ((i 0))
                (mapcar (lambda (x) (prog1 (list x `(+ *stack-depth* ,i)) (incf i)))
                        slot-names))
         (*stack-depth* (+ *stack-depth* ,(length slot-names))))
     (setf *max-stack-depth* (max *stack-depth* *max-stack-depth*))
     ,@body))

;; FIXME: import lap pulls in that EMIT symbol, and this would smash that.
;; need to implement shadowing symbols.
(defun %emit (&rest instructions)
  (dolist (i instructions)
    (setf (cdr *code-tail*) (cons i nil)
          *code-tail* (cdr *code-tail*))))

(defun value-constant-p (value)
  (and (listp value)
       (= (length value) 2)
       (eql (first value) 'quote)))

(defun var-ea (var)
  `(:rsp ,(* (var-stack-slot var) 8)))

(defun save-in-slot (slot loc)
  (cond ((and (value-constant-p loc)
              (integerp (second loc)))
         (%emit `(mov64 :rax ,(ash (second loc) 3))
               `(mov64 (:rsp ,(* slot 8)) :rax)))
        ((value-constant-p loc)
         (%emit `(mov64 :rax (:constant ,(second loc)))
               `(mov64 (:rsp ,(* slot 8)) :rax)))
        ((keywordp loc)
         (%emit `(mov64 (:rsp ,(* slot 8)) ,loc)))
        ((var-p loc)
         (%emit `(mov64 :rax ,(var-ea loc))
               `(mov64 (:rsp ,(* slot 8)) :rax)))
        (t (error "Unknown location ~S." loc))))

(defun move (reg loc)
  (cond ((and (value-constant-p loc)
              (integerp (second loc)))
         (%emit `(mov64 ,reg ,(ash (second loc) 3))))
        ((value-constant-p loc)
         (%emit `(mov64 ,reg (:constant ,(second loc)))))
        ((keywordp loc)
         (unless (eql loc reg)
           (%emit `(mov64 ,reg ,loc))))
        ((var-p loc)
         (%emit `(mov64 ,reg ,(var-ea loc))))
        (t (error "Unknown location ~S." loc))))

(defun compile-one-setf (place value for-value-p)
  (etypecase place
    (symbol (let ((var (find place *variable-info* :key 'var-name)))
              (when (var-constant-p var)
                (error "Variable ~S is constant." place))
              (multiple-value-bind (location type)
                  (compile-form value t)
                (setf (var-undefined-p var) nil
                      (var-type var) type)
                (cond ((keywordp location)
                       ;; Register.
                       (%emit `(mov64 (:rsp ,(* (var-stack-slot var) 8)) ,location)))
                      ((value-constant-p location)
                       ;; Constant value.
                       (if (typep (second location) '(signed-byte 29))
                           (%emit `(mov64 (:rsp ,(* (var-stack-slot var) 8)) ,(ash (second location) 3)))
                           (%emit `(mov64 :rax (:constant ,(second location)))
                                 `(mov64 (:rsp ,(* (var-stack-slot var) 8)) :rax))))
                      (t (error "Unknown location ~S." location)))
                (values location type))))
    (cons (let ((fn (gethash (first place) *setf-form-compilers*)))
            (cond (fn (funcall fn (list* (first place) value (rest place)) for-value-p 't))
                  ;; Attempt to compile as an accessor
                  (t (multiple-value-bind (location type)
                         (compile-form (second place) t)
                       (declare (ignore location))
                       (let ((struct (cond ((symbolp type)
                                            (get type 'sys.int::structure-type))
                                           ((and (consp type)
                                                 (= (length type) 2)
                                                 (eql (first type) 'eql))
                                            (get (type-of (second type)) 'sys.int::structure-type))))
                             (slot-offset 1))
                         (if (and struct
                                  (= (length place) 2))
                             (dolist (slot (sys.int::structure-slots struct)
                                      (error "No slot accessed through ~S in ~S (type ~S)." (first place) (second place) type))
                               (when (eql (second slot) (first place))
                                 (unless (third slot)
                                   (error "Slot ~S is read-only." (first slot)))
                                 (return (compile-struct-slot-writer value (second place) slot-offset (sys.int::structure-name struct) (fourth slot))))
                               (incf slot-offset))
                             (error "Cannot compile ~S. (inner type is ~S)." place type))))))))))

(define-form setf (&rest forms) (for-value-p)
  (do ((i forms (cddr i)))
      ((null (cddr i))
       (compile-one-setf (first i) (second i) for-value-p))
    (compile-one-setf (first i) (second i) nil)))

(defun compile-port-read (instruction length port)
  (multiple-value-bind (location type)
      (compile-form port t)
    ;; TODO: It would be nice to put a stronger guarantee on this.
    ;; Like (unsigned-byte 16).
    (assert (subtypep type 'fixnum))
    (cond ((and (value-constant-p location)
                (<= 0 (second location) #xFF))
           (%emit `(,instruction ,(second location))))
          ((value-constant-p location)
           (assert (<= 0 (second location) #xFFFF) ((second location))
                   "Port ~S out of range." (second location))
           (%emit `(mov16 :dx ,(second location))
                 `(,instruction :dx)))
          ((eql location :rdx)
           (%emit `(,instruction :dx)))
          ((keywordp location)
           (%emit `(mov64 :rdx ,location)
                 `(shr32 :edx 3)
                 `(,instruction :dx)))
          (t (error "Unknown location ~S." location)))
    (%emit `(and32 :eax #xFF)
          `(shl32 :eax 3))
    (values :rax `(unsigned-byte ,length))))

(define-form system:io-port/8 (port) (for-value-p)
  (compile-port-read 'in8 8 port))

(define-form quote (object) (for-value-p)
  (values (list 'quote object) (list 'eql object)))

(defun compile-if (test then else for-value-p)
  (let ((else-label (gensym "ELSE"))
        (fi-label (gensym "FI"))
        (tloc (compile-form test :predicate)))
    (cond ((assoc tloc sys.c::*predicate-instructions*)
           (%emit `(,(third (sys.c::predicate-info (sys.c::invert-predicate tloc))) ,else-label)))
          ((keywordp tloc)
           (%emit `(cmp64 ,tloc nil)
                 `(sys.je ,else-label)))
          ((var-p tloc)
           (%emit `(cmp64 (:rsp ,(* (var-stack-slot tloc) 8)) nil)
                 `(sys.je ,else-label)))
          (t (error "Unknown location ~S." tloc)))
    (multiple-value-bind (location type)
        (compile-form then for-value-p)
      (declare (ignore type))
      (assert (or (not for-value-p) (eql location :rax))))
    (%emit `(jmp ,fi-label)
          else-label)
    (multiple-value-bind (location type)
        (compile-form else for-value-p)
      (declare (ignore type))
      (assert (or (not for-value-p) (eql location :rax))))
    (%emit fi-label)
    (values nil 't)))

(define-form when (test &body body) (for-value-p)
  (compile-if test `(progn ,@body) nil for-value-p))

(define-form unless (test &body body) (for-value-p)
  (compile-if test nil `(progn ,@body) for-value-p))

(define-form if (test then else) (for-value-p)
  (compile-if test then else for-value-p))

(define-form progn (&rest forms) (for-value-p)
  (compile-forms forms for-value-p))

(define-form 1+ (number) (for-value-p)
  (multiple-value-bind (location type)
      (compile-form number t 'fixnum)
    (cond ((value-constant-p location)
           (values (list 'quote (1+ (second location))) 'fixnum))
          ((keywordp location)
           (%emit `(add64 ,location 8))
           (values location 'fixnum))
          ((var-p location)
           (%emit `(mov64 :rax ,(var-ea location))
                 `(add64 :rax 8))
           (values :rax 'fixnum))
          (t (error "Unknown location ~S." location)))))

(defun compile-struct-slot (object slot-number struct-type slot-type)
  (let ((location (compile-form object t struct-type)))
    (cond ((value-constant-p location)
           (%emit `(mov64 :rax (:constant ,(second location)))
                 `(mov64 :rax (:rax ,(+ -7 (* (1+ slot-number) 8))))))
          ((keywordp location)
           (%emit `(mov64 :rax (,location ,(+ -7 (* (1+ slot-number) 8))))))
          ((var-p location)
           (%emit `(mov64 :rax ,(var-ea location))
                 `(mov64 :rax (:rax ,(+ -7 (* (1+ slot-number) 8))))))
          (t (error "Unknown location ~S." location)))
    (values :rax slot-type)))

(defun compile-struct-slot-writer (value object slot-number struct-type slot-type)
  (with-stack-slots (struct)
    (save-in-slot struct (compile-form object t struct-type))
    (move :rax (compile-form value t slot-type))
    (%emit `(mov64 :rdx (:rsp ,(* struct 8)))
          `(mov64 (:rdx ,(+ -7 (* (1+ slot-number) 8))) :rax))
    (values :rax slot-type)))

(defmacro define-predicate (name pred)
  `(define-form ,name (x y) (for-value-p)
     (assert (eql for-value-p :predicate))
     (multiple-value-bind (xl xt)
         (compile-form x t 'fixnum)
       (assert (subtypep xt 'fixnum))
       (with-stack-slots (x-slot)
         (cond ((value-constant-p xl)
                (%emit `(mov64 :rax ,(ash (second xl) 3))
                      `(mov64 (:rsp ,(* x-slot 8)) :rax)))
               ((keywordp xl)
                (%emit `(mov64 (:rsp ,(* x-slot 8)) ,xl)))
               ((var-p xl)
                (%emit `(mov64 :rax ,(var-ea xl))
                      `(mov64 (:rsp ,(* x-slot 8)) :rax)))
               (t (error "Unknown location ~S." xl)))
         (multiple-value-bind (yl yt)
             (compile-form y t 'fixnum)
           (assert (subtypep yt 'fixnum))
           (cond ((value-constant-p yl)
                  (%emit `(mov64 :rax ,(ash (second yl) 3))
                        `(cmp64 (:rsp ,(* x-slot 8)) :rax)))
                 ((keywordp yl)
                  (%emit `(cmp64 (:rsp ,(* x-slot 8)) ,yl)))
                 ((var-p yl)
                  (%emit `(mov64 :rax ,(var-ea yl))
                        `(cmp64 (:rsp ,(* x-slot 8)) :rax)))
                 (t (error "Unknown location ~S." yl)))
           (values ',pred 'boolean))))))

(define-predicate = :e)
(define-predicate < :l)
(define-predicate > :g)
(define-predicate >= :ge)
(define-predicate <= :le)

(define-form length (thing) (for-value-p)
  (let ((loc (compile-form thing t '(simple-array * (*)))))
    (cond ((value-constant-p loc)
           (values (list 'quote (length (second loc)))
                   (list 'eql (length (second loc)))))
          ((keywordp loc)
           (%emit `(mov64 :rax (:simple-array-header ,loc))
                 `(shr64 :rax 5)
                 `(and64 :rax -8))
           (values :rax 'fixnum))
          ((var-p loc)
           (%emit `(mov64 :rax ,(var-ea loc))
                 `(mov64 :rax (:simple-array-header :rax))
                 `(shr64 :rax 5)
                 `(and64 :rax -8))
           (values :rax 'fixnum))
          (t (error "Unknown location ~S." loc)))))

(define-form (setf aref) (value vector index) (for-value-p)
  (with-stack-slots (vec idx)
    (multiple-value-bind (aloc array-type)
        (compile-form vector t '(simple-array * (*)))
      (save-in-slot vec aloc)
      (save-in-slot idx (compile-form index t 'fixnum))
      (move :rax (compile-form value t (second array-type)))
      (%emit `(mov64 :rcx (:rsp ,(* idx 8)))
            `(mov64 :rdx (:rsp ,(* vec 8))))
      (cond ((equal (second array-type) '(unsigned-byte 8))
             (%emit `(shr64 :rcx 3)
                   `(shr64 :rax 3)
                   `(mov8 (:rdx ,(+ -7 8) :rcx) :al))
             (when for-value-p
               (%emit `(shl64 :rax 3))))
            (t (error "Unsupported array type ~S." array-type)))
      (values :rax (second array-type)))))

(defun compile-forms (forms for-value-p)
  (do ((i forms (rest i)))
      ((null (rest i))
       (compile-form (first i) for-value-p))
    (compile-form (first i) nil)))

(defun compile-form (form for-value-p &optional (expected-type 't))
  (multiple-value-bind (location type)
      (typecase form
        (cons
         (let ((fn (gethash (first form) *form-compilers*)))
           (cond (fn (funcall fn form for-value-p expected-type))
                 ;; Attempt to compile as an accessor
                 (t (multiple-value-bind (location type)
                        (compile-form (second form) t)
                      (declare (ignore location))
                      (let ((struct (cond ((symbolp type)
                                           (get type 'sys.int::structure-type))
                                          ((and (consp type)
                                                (= (length type) 2)
                                                (eql (first type) 'eql))
                                           (get (type-of (second type)) 'sys.int::structure-type))))
                            (slot-offset 1))
                        (if (and struct
                                 (= (length form) 2))
                            (dolist (slot (sys.int::structure-slots struct)
                                     (error "No slot accessed through ~S in ~S (type ~S)." (first form) (second form) type))
                              (when (eql (second slot) (first form))
                                (return (compile-struct-slot (second form) slot-offset (sys.int::structure-name struct) (fourth slot))))
                              (incf slot-offset))
                            (error "Cannot compile ~S. (inner type is ~S)." form type))))))))
        (symbol
         (let ((var (find form *variable-info* :key 'var-name)))
           (cond
             (var (cond
                    ((var-constant-p var)
                     (values (list 'quote (var-value var))
                             (list 'eql (var-value var))))
                    ((var-undefined-p var)
                     (error "Variable ~S used before definition." form))
                    (t (values var (var-type var)))))
             ((constantp form)
              (values (list 'quote (symbol-value form))
                      (list 'eql (symbol-value form))))
             (t (error "Undefined variable/constant ~S." form)))))
        (t (values (list 'quote form) (list 'eql form))))
    (assert (subtypep type expected-type)
            (type expected-type)
            "Result type ~S of form ~S is not compatible with expected type ~S."
            form type expected-type)
    (values location type)))

(defun generate-code (template arguments)
  (let* ((*stack-depth* 0)
         (*variable-info* (append (mapcar (lambda (arg var)
                                            (make-var :name var
                                                      :constant-p t
                                                      :value arg
                                                      :undefined-p nil))
                                          arguments
                                          (interrupt-handler-template-arguments template))
                                  (mapcar (lambda (var)
                                            (prog1 (make-var :name var
                                                             :constant-p nil
                                                             :undefined-p t
                                                             :stack-slot *stack-depth*)
                                              (incf *stack-depth*)))
                                          (interrupt-handler-template-variables template))))
         (*max-stack-depth* *stack-depth*)
         (code (cons nil nil))
         (*code-tail* code))
    (compile-forms (interrupt-handler-template-body template) nil)
    (nconc (list `(sub64 :rsp ,(* *max-stack-depth* 8)))
           (rest code)
           (list `(add64 :rsp ,(* *max-stack-depth* 8))
                 `(ret)))))

(defun make-interrupt-handler (name &rest arguments)
  (let ((template (get name 'interrupt-handler)))
    (assert template () "~S does not name an interrupt handler." name)
    (assert (eql (length arguments) (length (interrupt-handler-template-arguments template))))
    (multiple-value-bind (mc pool)
        (assemble (generate-code template arguments)
          :base-address 12
          :info (list* template arguments))
      (sys.int::make-function mc pool))))
