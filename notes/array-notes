Array modes
    00 SIMPLE
    01 FULL
    10 DISPLACED
    11 MEMORY

Array header word
...total size(48)| array-rank (4) | array-mode (2 bits) | array-type (6 bits) | ARRAY-HEADER TAG (4-bits)
  Array rank is stored -1. so vectors (rank 1) are stored as rank=0
  For arrays with rank > 1, the dimensions are stored left-to-right as fixnums following the array
  header word.
  Simple arrays store the elements in row-major format after the array dimension words or header word.
  |array-header|dimension-0|dimension-1|dimension-n|data-0|data-1|...|data-n|
  Full arrays store a simple array after the array dimension words or the header word if there are
  no dimension words.
  If the array is a vector, a fill-pointer is stored after the header word.
  |array-header|fill-pointer|dimension-0|dimension-1|dimension-n|fill-pointer|simple-array|
  Ignores the array-type field.
  Displaced arrays store the array they are displaced on and the displacement offset after the
  dimension words/header word.
  If the array is a vector, a fill-pointer is stored after the header word.
  |array-header|fill-pointer|dimension-0|dimension-1|dimension-n|displaced-array|displaced-index-offset|
  Ignores the array-type field.
  Memory arrays store the memory address as a fixnum after the dimension words/header word.
  |array-header|dimension-0|dimension-1|dimension-n|address|

Array element types:
  000000 T (Should be zero, so SIMPLE-VECTORs can be tested for with one instruction)
  000001 NIL
  000010 BASE-CHAR (Base-char and character differ by one bit, allowing
  000011 CHARACTER  strings to be tested for with one mask & comparison)
  000100 BIT
  000101 (UNSIGNED-BYTE 2)
  000110 (UNSIGNED-BYTE 4)
  000111 (UNSIGNED-BYTE 8)
  001000 (UNSIGNED-BYTE 16)
  001001 (UNSIGNED-BYTE 32)
  001010 (UNSIGNED-BYTE 64)
  001011 (SIGNED-BYTE 1)
  001100 (SIGNED-BYTE 2)
  001101 (SIGNED-BYTE 4)
  001110 (SIGNED-BYTE 8)
  001111 (SIGNED-BYTE 16)
  010000 (SIGNED-BYTE 32)
  010001 (SIGNED-BYTE 64)
  010010 SHORT-FLOAT (?)
  010011 SINGLE-FLOAT
         Data starts at +16, not +8 for alignment.
  010100 DOUBLE-FLOAT
         Data starts at +16, not +8 for alignment.
  010101 LONG-FLOAT
         Data starts at +16, not +8 for alignment.
  010110 (COMPLEX SHORT-FLOAT) (?)
  010111 (COMPLEX SINGLE-FLOAT)
         Data starts at +16, not +8 for alignment.
  011000 (COMPLEX DOUBLE-FLOAT)
         Data starts at +16, not +8 for alignment.
  011001 (COMPLEX LONG-FLOAT)
         Data starts at +16, not +8 for alignment.
  011010 XMM-VECTOR
         Data starts at +16, not +8 for alignment.
  ------ Non-array array-like types.
  110011 Complex Short-Float (?)
  110100 Complex Single-Float
         Data starts at +16, not +8 for alignment.
  110101 Complex Double-Float
         Data starts at +16, not +8 for alignment.
  110110 Complex Long-Float
         Data starts at +16, not +8 for alignment.
  110111 XMM-Vector
         Data starts at +16, not +8 for alignment.
  111000 Double-Float
         Data starts at +16, not +8 for alignment.
  111001 Long-Float
         Data starts at +16, not +8 for alignment.
  111010 Ratio
  111011 Bignum
  111100 *Unused
  111101 Stack-Group
  111110 Standard-Object
         When mode=simple:
          First element is the class. Remaining elements
          hold the slots.
          There will always be at least two elements to allow
          conversion to FULL mode.
         When mode=full:
          First element is the class. Second element is
          a simple-vector holding the slots.
          This mechanism is required to support CHANGE-CLASS,
          while preserving the identity of objects.
         The GC will attempt to flatten FULL standard-objects.
  111111 Structure-Object
         First element is the structure type. Remaining
         elements hold the slots.
