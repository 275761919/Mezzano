void fill_rgba_1bit_mask(int nrows, int ncols, uint32_t colour,
                         uint8_t *mask, int mask_row, int mask_col, int mask_width, int mask_height,
                         uint32_t *dest, int dest_row, int dest_col, int dest_width, int dest_height)
{
  // Only need to clamp values below zero here. nrows/ncols will
  // end up negative if the source/target positions are too large.
  // Clamp to row/column.
  if(dest_row < 0) {
    nrows += dest_row;
    mask_row -= dest_row;
    dest_row = 0;
  }
  if(dest_col < 0) {
    ncols += dest_col;
    mask_col -= dest_col;
    dest_col = 0;
  }
  // Clamp from row/column.
  if(mask_row < 0) {
    nrows += mask_row;
    to_row -= mask_row;
    mask_row = 0;
  }
  if(mask_col < 0) {
    ncols += mask_col;
    to_col -= mask_col;
    mask_col = 0;
  }
  // Clamp nrows/ncols.
  nrows = min(nrows, dest_height - dest_row, mask_height - mask_row);
  ncols = min(ncols, dest_height - dest_col, mask_height - mask_col);
  // Leave early if not copying anything.
  if(nrows <= 0 || ncols <= 0) return;

  for(int y = 0; y < nrows; ++y) {
    for(int x = 0; x < ncols; ++x) {
      int mask_offset = (mask_col+x) + (mask_row+y)*mask_width/8;
      int mask_alpha = (mask[mask_offset / 8] >> (mask_offset % 8)) & 1;
      if(mask_alpha == 0) continue;
      alpha_blend_one(dest, (dest_col+x) + (dest_row+y)*dest_width, colour);
    }
  }
}

void alpha_blend_one(uint32_t *dest, uint dest_offset, uint32_t colour)
{
  uint8_t ca = ((colour >> 24) & 0xFF);
  uint8_t cr = ((colour >> 16) & 0xFF);
  uint8_t cg = ((colour >>  8) & 0xFF);
  uint8_t cb = ((colour >>  0) & 0xFF);
  if(ca == 0) {
    return;
  }
  if(ca == 255) {
    dest[dest_offset] = (int(ca) << 24) | (int(cr) << 16) | (int(cg) << 8) | (int(cb) << 0);
    return;
  }
  uint32_t s = dest[(dest_col+x) + (dest_row+y)*dest_width];
  uint8_t sa = ((s >> 24) & 0xFF);
  uint8_t sr = ((s >> 16) & 0xFF);
  uint8_t sg = ((s >>  8) & 0xFF);
  uint8_t sb = ((s >>  0) & 0xFF);

  // Compute Final colour.
  uint8_t fa = ca + sa * (255-ca);
  uint8_t fr = (cr*ca + sr*sa * (255-ca)) / fa;
  uint8_t fg = (cg*ca + sg*sa * (255-ca)) / fa;
  uint8_t fb = (cb*ca + sb*sa * (255-ca)) / fa;
  dest[dest_offset] = (int(fa) << 24) | (int(fr) << 16) | (int(fg) << 8) | (int(fb) << 0);
}

void alpha_blend_one_faster(uint32_t *dest, uint dest_offset, uint32_t colour)
{
  uint8_t ca = ((colour >> 24) & 0xFF);
  uint8_t cr = ((colour >> 16) & 0xFF);
  uint8_t cg = ((colour >>  8) & 0xFF);
  uint8_t cb = ((colour >>  0) & 0xFF);
  if(ca == 0) {
    return;
  }
  if(ca == 255) {
    dest[(dest_col+x) + (dest_row+y)*dest_width] = (int(ca) << 24) | (int(cr) << 16) | (int(cg) << 8) | (int(cb) << 0);
    return;
  }
  uint32_t s = dest[(dest_col+x) + (dest_row+y)*dest_width];
  uint8_t sa = ((s >> 24) & 0xFF);
  uint8_t sr = ((s >> 16) & 0xFF);
  uint8_t sg = ((s >>  8) & 0xFF);
  uint8_t sb = ((s >>  0) & 0xFF);

  // Compute Final colour.
  uint8_t fa = ca + sa * (255-ca);
  uint8_t fr = (cr*ca + sr*sa * (255-ca)) / fa;
  uint8_t fg = (cg*ca + sg*sa * (255-ca)) / fa;
  uint8_t fb = (cb*ca + sb*sa * (255-ca)) / fa;
  dest[(dest_col+x) + (dest_row+y)*dest_width] = (int(fa) << 24) | (int(fr) << 16) | (int(fg) << 8) | (int(fb) << 0);
}
