(defstruct ps/2-fifo
  (head 0 :type fixnum)
  (tail 0 :type fixnum)
  (buffer (make-array 500 :element-type '(unsigned-byte 8))
          :type (simple-array (unsigned-byte 8) (*))))

(defconstant +ps/2-data-port+ #x60)

(define-interrupt-handler ps/2-interrupt (fifo &aux data x)
  (setf data (io-port/8 +ps/2-data-port+))
  (setf x (1+ (ps/2-fifo-tail fifo)))
  (when (>= x (length (ps/2-fifo-buffer fifo)))
    (setf x 0))
  ;; When next reaches head, the buffer is full.
  (unless (= x (ps/2-fifo-head fifo))
    (setf (aref (ps/2-fifo-buffer fifo) (ps/2-fifo-tail fifo)) data
          (ps/2-fifo-tail fifo) x))
  't)

(setf (pic-interrupt-handler +ps/2-key-irq+) (make-interrupt-handler ps/2-interrupt key-fifo)
      (pic-interrupt-handler +ps/2-aux-irq+) (make-interrupt-handler ps/2-interrupt aux-fifo))

;;; Dumb, with everything as a s-b64 and no CSE.
(in8 #x60)
(and32 :eax #xFF) ; rax = (signed-byte 64)
(mov64 :r8 (:constant fifo))
(mov64 :rcx (ps/2-fifo-tail :r8)) ; rcx = fixnum
(sar64 :rcx 3) ; rcx = (signed-byte 64)
(add64 :rcx 1)
(mov64 :r9 (ps/2-fifo-buffer :r8)) ; r9 = (simple-array (unsigned-byte 8) (*))
(mov64 :rdx (array-header :r9))
(shr64 :rdx 8) ; rdx = (signed-byte 64)
(cmp64 :rcx :rdx)
(jnge L01)
(xor32 :ecx :ecx)
L01
(mov64 :rsi (ps/2-fifo-head :r8)) ; rsi = fixnum
(sar64 :rsi 3) ; rsi = (signed-byte 64)
(cmp64 :rcx :rsi)
(je L02)
(mov64 :rdi (ps/2-fifo-tail :r8)) ; rdi = fixnum
(sar64 :rdi 3) ; rsi = (signed-byte 64)
(mov8 (:r9 #.(+ (- +tag-array-like+) 8) (:rdi 8)) :al)
(shl64 :rcx 3)
(mov64 (ps/2-fifo-tail :r8) :rcx)
L02
(mov64 :r8 t)
(ret)

;;; smarter
(in8 #x60) ; al = data as (unsigned-byte 8)
(mov64 :r8 (:constant fifo))
(mov64 :rcx (ps/2-fifo-tail :r8)) ; rcx = fifo-tail as fixnum
(lea64 :rdx (:rcx 8)) ; rdx = x as fixnum
(mov64 :r9 (ps/2-fifo-buffer :r8)) ; r9 = fifo-buffer as (simple-array (unsigned-byte 8) (*))
(mov64 :rsi (array-header :r9))
(shr64 :rsi 5)
(and64 :rsi -8) ; rsi = (length buffer) as fixnum
(cmp64 :rdx :rsi)
(jnge L01)
(xor32 :edx :edx)
L01
(mov64 :rsi (ps/2-fifo-head :r8)) ; rsi = fifo-head as fixnum
(cmp64 :rdx :rsi)
(je L02)
(mov8 (:r9 #.(+ (- +tag-array-like+) 8) :rcx) :al)
(mov64 (ps/2-fifo-tail :r8) :rdx)
L02
(mov64 :r8 t)
(ret)

;;; even smarter
(in8 #x60) ; al = data as (unsigned-byte 8)
(mov64 :r8 (:constant fifo))
(mov64 :rcx (ps/2-fifo-tail :r8)) ; rcx = fifo-tail as fixnum
(lea64 :rdx (:rcx 8)) ; rdx = x as fixnum
(mov64 :r9 (ps/2-fifo-buffer :r8)) ; r9 = fifo-buffer as (simple-array (unsigned-byte 8) (*))
(mov64 :rsi (array-header :r9))
(shr64 :rsi 5)
(and64 :rsi -8) ; rsi = (length buffer) as fixnum
(xor32 :edi :edi)
(cmp64 :rdx :rsi)
(cmovge :rdx :rdi)
(mov64 :rsi (ps/2-fifo-head :r8)) ; rsi = fifo-head as fixnum
(cmp64 :rdx :rsi)
(je L02)
(mov8 (:r9 #.(+ (- +tag-array-like+) 8) :rcx) :al)
(mov64 (ps/2-fifo-tail :r8) :rdx)
L02
(mov64 :r8 t)
(ret)

